# Escaneo de IPs

En primer lugar cuando nos enfrentamos a una red es importante entender desde que IP estamos trabajando. Habitualmente trabajaremos sobre Linux pero quizás puedas estar haciendo pentesting desde Windows.

### ¿En qué IP estoy?

#### Linux

```
ifconfig

Tun0:    inet 10.10.16.36 netmask 255.255.255.255 destination 10.10.16.36
         inet6 fe80::c17e:568e:8590:3cb1 prefixlen 64 scopeid 0x20<link>
         inet6 dead:beef:4::1022 prefixlen 64 scopeid 0x0<global>
# Puede haber más información
```

Realmente aquí lo importante que tenemos que fijarnos es en la netmask y en nuestra IP (inet)

En este caso concretamente sabemos que nos encontramos en la IP 10.10.16.36 y la máscara de red nos está diciendo que podemos encontrar redes abiertas en el rango 10.10.16.0-255 (Esto será importante cuando montemos un script que nos pueda descubrir redes abiertas en dicho rango)

#### Windows

```
ipconfig

Ethernet adapte Ethernet:

   Connection-specific DNS Suffix  . : openstacklocal
   Link-local IPv6 Address . . . . . : fe80::b12e:8f7c:42b8:a3b9%4
   IPv4 Address. . . . . . . . . . . : 10.10.16.36
   Subnet Mask . . . . . . . . . . . : 255.255.255.255
```

Podemos observar nuestra IP:10.10.16.36 y sabemos que podemos buscar IPs en el rango que nos permite la Subnet Mask.

### Buscar máquinas en nuestra red

Para ello podemos utilizar herramientas externas como nmap, crear nuestras propias herramientas o utilizar scripting sencillo para realizar los distintos escaneos. Vamos a usar como base la información anterior.

#### Nmap

```
nmap -sn 10.10.16.0/24
nmap -sn 10.10.0.0/16 #Si quisiesemos buscar en un rango más amplio por la netmask
nmap -sn 10.10.16.*
nmap -sn 10.10.16.0-255
```

#### Fping

```
fping -a -g IPRANGE
fping -a -g 10.10.16.0/24
fping -a -g 10.10.16.0 10.10.16.255
fping -a -g 10.10.16.0/24 2>/dev/null #Redireccionamos los errores por comodidad
```

#### Script en Bash

```
#!/bin/bash

trap ctrl_c INT

function ctrl_c(){
	echo -e "\n\n[*]Parando...\n"
	exit 0
}

ip=$1

for i in $(seq 0 255); do
	timeout 1 ping -c 1 $(echo "$ip.$i") > /dev/null 2>&1 && echo "$ip.$i Is UP" >> tmpscan.txt &
done; wait

cat tmpscan.txt | sort -n
rm tmpscan.txt

```

¿Qué estamos haciendo? En primer lugar nos aseguramos de que la función ctrl\_c para cancelar funciona correctamente.

A continuación realizamos un bucle a las 255 posibles direcciones, ponemos un tiempo de espera máximo de 1 segundo y realizamos un ping que sólo nos devuelve positivo en caso de que el ping haya funcionado. Lo introducimos en un documento de texto temporal para que nos lo muestra ordenado.

Para más información ver [script en bash](../../programacion/bash.md)

#### Script en Windows

```
1..20 | % {"192.168.1.$($_): $(Test-Connection -count 1 -comp 192.168.1.$($_) -quiet)"}
```

Actualmente sólo conozco este script, pero es extremadamente lento, en un futuro cuando aprenda más de script en powershell lo actualizaré.



> \*Disclaimer: Este manual está realizado en base a lo que voy aprendiendo, si parte de la información que comparto no es correcta estaré encantado de que te pongas en contacto conmigo para hacérmelo saber y poder modificarlo.
