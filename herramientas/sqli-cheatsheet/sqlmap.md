---
description: Os comparto un trabajo que realicé en el máster sobre esta herramient
---

# SQLmap

## Introducción

Es una herramienta que nos permite automatizar el proceso de detección y explotación de inyecciones SQL. Os muestro un ejemplo tras toda la explicación al final de uno de sus posibles usos.&#x20;

Además no terminan sus funcionalidades simplemente en la inyección SQL sino que permite cracking de hashes, ejecución remota de comandos, subir y descargar archivos e incluso crear una reverse Shell, por esta razón es tan conocida a la hora de explotar cualquier tipo de vulnerabilidad SQLI.&#x20;

Aunque voy a intentar explicar a fondo gran parte de las funciones de esta herramienta tiene dos modos para poder ver todas las opciones de las que dispone, uno es el -h y otro el -hh (el más completo).&#x20;

El uso básico es bastante sencillo, Tienes que especificar con el parámetro -u la URL que quieres comprobar y dejas que haga el trabajo, vamos a hacer un caso sencillo de uso, pongamos que tenemos un web vulnerable a un sql Injection en&#x20;

hxxp://webvulnerable.com/cambiodeinfo.php?id=1&#x20;

Simplemente usando el siguiente comando:&#x20;

```
sqlmap -u “hxxp://webvulnerable.com/cambiodeinfo.php?id=1” 
```

Ya es el propio Sqlmap el que se encarga de comprobar que efectivamente sea vulnerable a algún tipo de inyección.

### ¿Cuál es el problema?

El problema que puede tener utilizar Sqlmap de esta forma es tanto la posibilidad de no encontrar nada cómo el número de inyecciones que pueda llegar a utilizar, es decir, la cantidad de peticiones para comprobar qué tipo de vulnerabilidad y de qué base de datos.

Además existen opciones avanzadas que en ocasiones hay que utilizar, cómo parámetros POST, Cookies de sesión, Realización a través de TOR, número de hilos…

Para hacernos una idea en el nivel de riesgo más bajo que se puede hacer, haciéndolo a un enlace sin vulnerabilidades a SQLI llega a hacer hasta 165 peticiones Figura 1.

![Figura 1: SQL bajo riesgo](https://lh5.googleusercontent.com/qNV9KjtFK6b-CsN7PuQD7r4AmFVPhUegmT4isb4cigEBxKP7rFt6jc815t1Spq2abjzOT3iVxBCABq15UYTFFBwiTmt9yUX\_WYvJcM33MqEpCMiP2HLPQWCKeGsmapdb1kJzzp1kM7h64Nrx5g)

Y eso que está en el nivel de riesgo más bajo, si incrementamos este nivel de riesgo llega a 11615 peticiones Figura 2.

```
--risk 3 --level 3
```

![Figura 2: SQL alto riesgo](https://lh3.googleusercontent.com/kdGOM9t\_EetWKZD8ZodjCPHj5c1DrW-5uZh0\_aMqbyWwY50KM-JuCESpSEwNcKG7xmiJ96371Zrmb\_0mqrXH1ghtOvxvlkfdZP9Tn2WnbkzLhzLcUh6NSz1AXSSC98hiwuZLo9BL3zUDDWbWOw)

Esto lo comento debido a que es importante que no lancemos herramientas a lo loco para hacer una auditoría ya que si no controlamos lo que estamos haciendo podemos hacer más mal que bien. Imaginad una denegación de servicio, o tocar algo que no debemos, incluso hacer saltar ciertas protecciones lo que conlleva que pueda banear tu IP y que tengas que recurrir a otra o llamar a la empresa para que lo reviertan.

## Opciones para controlar las peticiones

Por esta razón cuantos más datos podamos dar a Sqlmap menos peticiones y más controladas realizará. Por ejemplo, si sabemos el tipo de base de datos podemos especificarla, pongamos el caso de que a través de alguna enumeración, o información filtrada hemos descubierto la base de datos que trabaja detrás. ¿Para qué vamos a enviar Payloads de todas si ya sabemos cual es el objetivo? Esta petición la podemos realizar con el siguiente argumento:&#x20;

```
--dbms=mysql 
```

O también la query que se va a utilizar&#x20;

```
--sql-query=UNION SELECT 
```

También podemos añadir un prefijo y un sufijo de la siguiente forma:&#x20;

```
--prefix = “‘“ --suffix =’ - a ‘ 
```

Con este tipo de cambios en el ejemplo anterior podríamos disminuir hasta 50 el número de peticiones, si a esto le incluimos la base de datos hasta 40 peticiones.&#x20;

Con esto lo que quiero hacer ver es que es importante que tampoco se lance siempre Sqlmap a lo loco, tiene muchas opciones y a la herramienta se le puede sacar más partido si aprendemos a utilizarla correctamente.&#x20;

Otra de las opciones que nos permite Sqlmap para controlar las peticiones son los test, tenemos dos opciones:&#x20;

```
--test-filter = ‘ORDER BY’ 
```

Nos permite filtrar el tipo de test que queremos realizar. Por ejemplo puede que queramos probar aquellos Payloads que contengan order by y no todo lo demás ya que con eso consideramos que ya va a encontrar algo.&#x20;

Por otro lado tenemos:&#x20;

```
--test-skip= ‘ORDER BY’ 
```

Puede que lo que estemos buscando aquí es efectivamente saltarnos algunos de los tests, por ejemplo puede que para nosotros sea suficiente con los tests a base de añadir Nulls para el Union query y no consideremos necesario que pruebe ‘ORDER BY’o quizás todo lo contrario.&#x20;

También existen opciones para determinar el parámetro inyectable:&#x20;

```
-p “id” 
```

Incluso lo contrario, parámetros que no queremos probar:&#x20;

```
--skip=”referer” 
```

Realmente con esto lo que vemos es la cantidad de opciones de filtrado que nos permite utilizar y cada una de ellas puede ser útil en ciertos casos particulares.

### Parámetros típicos de control de peticiones

Existen parámetros típicos que nos ayudan a controlar las peticiones y que muy probablemente tengamos que usar en más de una ocasión, por lo que es importante que los aprendamos a utilizar.&#x20;

No siempre vamos a vulnerar a través de peticiones GET por lo que para hacerle entender a Sqlmap lo que buscamos en muchas ocasiones deberemos introducir la data que será enviada por POST.&#x20;

```
--data “username=pepe&pass=password” 
```

Sqlmap detecta automáticamente una petición POST cuando introducimos el argumento anterior, por lo que no será necesario utilizar el argumento --method.&#x20;

¿Y si intentamos vulnerar un sitio web en el que debemos estar logueados? Probablemente tengamos que introducir una cookie de sesión o de algún otro tipo:&#x20;

```
--cookie=”ID=2; PHPSESSID=543AF56…” 
```

Incluso nos podemos encontrar que tengamos el problema de que la única manera que responda un formulario es si viene referido de una página concreta y para ello debemos cambiar dicha cabecera HTTP:&#x20;

```
--referer=”target.com*” 
```

Aparte tenemos otras opciones cómo los method, headers, autenticaciones HTTP y algunos parámetros extras que podemos ver con la ayuda del propio Sqlmap.

### Técnicas a utilizar

Otro de los argumentos que tiene Sqlmap es la técnica a utilizar, ¿Cuándo utilizarlo?, Pongamos que nos imaginamos la técnica que puede funcionar, o la que no. También puede ocurrir que manualmente hayamos encontrado la vulnerabilidad pero queremos que Sqlmap nos facilite la recolección de la información ya que podemos exportar los resultados de formas más amigables.&#x20;

Para estos casos en los que no necesitamos probar todas las técnicas o ya sabemos cual hay que probar podemos utilizar lo siguiente:&#x20;

```
--technique=TÉCNICA 
```

La pregunta ahora son las técnicas que Sqlmap soporta, tenemos en total 6 técnicas, la letra entre paréntesis sería el nombre a utilizar en el argumento por ejemplo:&#x20;

```
--technique=U 
```

* Stacked Queries (S)&#x20;
* Union query based (U)&#x20;
* Error based (E)&#x20;
* Inline queries (I)&#x20;
* Boolean blind (B)&#x20;
* Time based blind (T)&#x20;

A medida que vamos aprendiendo los distintos argumentos que tiene el programa tenemos que aprender a juntarlos.&#x20;

Pongamos de ejemplo que queremos únicamente probar las posibles inyecciones que pueden afectar al campo de usuario de un formulario de login y que sean SQL Time Based conociendo la base de datos que existe detrás que es MYSQL:&#x20;

```
sqlmap -u “http://10.10.10.10/webvulnerable” --dbms=mysql --data “username=pepe&pass=password” -p “username” --technique=T 
```

Si os fijáis en la consulta anterior estamos lanzando Sqlmap contra una URL determinada, especificando el tipo de la base de datos, la data por POST utilizada, el campo vulnerable y la técnica que queremos aplicar.&#x20;

Utilizar Sqlmap es más interesante de esta manera que lanzar únicamente contra la web vulnerable y esperar a ver que pasa. Además de controlar mucho más las peticiones realizadas.&#x20;

Además tenemos otras opciones a utilizar junto con las técnicas:&#x20;

1. \--time-sec → Tiempo en segundo para un Time Based (def 5)&#x20;
2. \--union-cols → Número de columnas para un Union based&#x20;
3. \--union-char → Carácter para realizar fuerza bruta&#x20;
4. \--union-from → Tabla a usar para el FROM de un Union based&#x20;
5. \--second-order → Página externa en la que buscar la respuesta del SQLI

### Opciones de detección

Para realizar algunas inyecciones tenemos que especificar qué contenido de la respuesta es el que le hace distinguir si es verdadera o falsa. No siempre es tan fácil para Sqlmap determinarlo y para esto tenemos:&#x20;

* \--string: Cadena de texto a buscar cuando la inyección ha sido exitosa.&#x20;
* \--not-string: Cadena de texto que no debería aparecer en una inyección exitosa.&#x20;
* \--regexp: Expresión regular cuando la inyección es exitosa&#x20;
* \--code: Código HTTP para evaluar si ha sido exitosa (200, 401)&#x20;
* \--text-only: Cuando hay grandes diferencias en el body&#x20;
* \--titles: Título de la página cuando es exitosa&#x20;
* \--null-connection: Sin tener que cargar todo el cuerpo del mensaje únicamente determina el tamaño de este.&#x20;

Aunque los nombres son bastante descriptivos he dejado una breve explicación de cada uno.

## Enumeración

Algo muy importante también a realizar con Sqlmap es la enumeración, no siempre es necesario que accedamos a absolutamente todo el contenido de la base de datos aunque podemos hacerlo:&#x20;

```
--dump-all 
--all 
```

Puede que sea más interesante acceder únicamente a cierta información e ir filtrando en función de lo que vayamos necesitando al igual que lo haríamos de forma manual. Por ejemplo podríamos ir pidiendo dato a dato:&#x20;

1. \--current-db → Nombre de la base de datos en uso&#x20;
2. \--tables -D “baseenuso” → Las tablas de dicha BD&#x20;
3. \--columns -D “basenuso” -T “tablaquenosinteresa” → Las columnas&#x20;
4. \--dump -D “baseenuso” -T “tablaquenosinteresa” -C “columna1,columna2” → Los datos&#x20;

Por supuesto tenemos otras opciones por defecto que podemos buscar a través de Sqlmap:&#x20;

* \--current-user → Usuario actual de la BD&#x20;
* \--hostname → El nombre del servidor&#x20;
* \--users → Usuarios de la BD&#x20;
* \--passwords → hashes de contraseña de los usuarios de la BD&#x20;
* \--privileges → Privilegios de dichos usuarios&#x20;
* \--roles → Roles de dichos usuarios Y además tenemos otras opciones de enumeración aparte de las mencionadas:&#x20;
* \--dbs → Enumerar todas las Bases de datos&#x20;
* \--schema → Enumerar el esquema&#x20;
* \--count → Número de entradas de la tabla&#x20;
* \--search → buscar por algo concreto&#x20;
* \--comments → Comentarios de la BD&#x20;

Y algunos filtros:&#x20;

* \-X → Excluir algún parámetro&#x20;
* \--exclude-sysdbs → Excluir las tablas del sistema de base de datos cuando se enumeran las tablas&#x20;
* \--where= → usar la condición Where&#x20;
* \--start= → Comenzar a partir de cierta entrada&#x20;
* \--stop= → Parar en cierta entrada&#x20;

Por supuesto existen otros filtros que podéis ver en el apartado de ayuda de Sqlmap y que en ciertas situaciones pueden ser de utilidad. Además podéis crear una Shell directa a la base de datos para realizar las consultas:&#x20;

```
--sql-shell
```

## Acceso al sistema

Aunque no me quiero meter a fondo en este tema concreto de Sqlmap ya que habría mucho más de lo que hablar por detrás es interesante conocer que también permite aprovechar las vulnerabilidades encontradas para dar un paso más allá y acceder al sistema.&#x20;

Tenemos comandos como ‘--os-shell’ que nos permite tener una reverse shell en el sistema, al igual que otros como pwn, smbrelay e incluso a través de buffer overflow.&#x20;

Además tiene opciones específicas para Windows que nos permite leer y modificar los distintos registros:&#x20;

```
--reg-read,add,del,key,value,data,type 
```

o también buscar leer, reescribir y leer distintos archivos del sistema.&#x20;

```
--file-read,write,dest 
```

En definitiva muchas más opciones para trastear, aprender y facilitar el trabajo también en un entorno de pentesting.

## Detección WAF

Existe un uso que se le puede dar a Sqlmap para poder saltar la protección de los Web Application Firewall (WAF) Los WAFs son cortafuegos contra muchas de las vulnerabilidades webs que se dan a día de hoy.

### Tamper

Un tamper en Sqlmap nos permite insertar los Payloads camuflados, la ubicación de los tamper está en:&#x20;

```
/usr/share/sqlmap/tamper 
```

Para hacernos una idea vamos a describir algunos:&#x20;

* space2comment.py → sustituye un carácter de espacio con otras inserciones&#x20;
* charencode.py → codifica todos los caracteres con numérico&#x20;
* base64encode.py → convierte todos los caracteres a base64&#x20;

El listado es especialmente grande por lo que tendréis que jugar un poco con cada uno de ellos para entenderlo.

### Conexión por TOR

También puede ocurrir que queramos ocultar nuestra IP por algún motivo, puede ser un posible baneo, detección de exceso de peticiones por cada IP...&#x20;

Sqlmap nos proporciona la posibilidad de conectarnos a través de TOR, esto también permite que podamos hacer cierto número de peticiones y utilizar los filtros en cada una.&#x20;

Para no agenciarme un tutorial que no es mío la explicación de cómo conectar con TOR la tenéis aquí debajo, yo simplemente la he traducido&#x20;

https://www.yeahhub.com/anonymity-sqlmap-tor-proxy-kali-linux-2018/&#x20;

1. En primer lugar debemos instalar tor en nuestro Linux → apt-get install tor&#x20;
2. Lo ponemos en marcha en un terminal (Que no debemos cerrar) → tor&#x20;
3. Nos debemos asegurar que está corriendo socks5 y en el puerto 9050.&#x20;
4. Lo usamos con Sqlmap → sqlmap -u --tor --tor-type=SOCKS5 --check-tor&#x20;

Utilizar ‘check-tor’ es altamente recomendable para asegurarnos de que está funcionando correctamente en cada momento. En el ejemplo del tutorial que os he compartido podéis ver cómo además utiliza el comando user-agent para hacerse pasar por un bot de google.&#x20;

```
--user-agent=”Googlebot(compatible; Googlebot/2.1; +http://www.google.com/bot.html)” 
```

También existe la opción de utilizar --random-agent para usar uno aleatorio.

### Otros

Podemos especificar otros parámetros como el delay, los intentos, tiempo de espera… Todo esto nos permite poder saltarnos ciertas protecciones y controlar mucho mejor la forma en que el programa actúa.&#x20;

1. \--delay → Tiempo en segundos entre las distintas peticiones&#x20;
2. \--timeout → Segundos de espera de respuesta del servidor (def 30)&#x20;
3. \--retries → Número de intentos tras un timeout (def 3)&#x20;
4. \--csrf-token → Parámetro usado para saltarse la protección anti-CSRF&#x20;
5. \--csrf-url → URL a visitar para extraer el token anti-CSRF&#x20;
6. \--threads → Máximo número de peticiones en paralelo

## Depuración

\--flush-session → Nos permite eliminar los datos almacenados para poder empezar de cero, esto puede ser útil cuando queremos probar otro payload distinto que sea más relevante para la actual sesión.

## Aprendizaje, entender y controlar Sqlmap

Creo que es importante destacar algo acerca de Sqlmap y otras herramientas automáticas, en principio y usadas tal cual no son la mejor manera de aprender, pero sabiendo cómo utilizarlas podemos acelerar nuestro aprendizaje o sacarnos de bloqueos en momentos determinados.&#x20;

Sqlmap tiene las opciones de Verbose, estas opciones nos permiten ver qué está pasando por detrás y que opciones está haciendo por qué razones. Además al contrario que en otros programas que el verbose te da sólo algunos datos aquí puedes poner el nivel de verbose y es increíble la cantidad de información que te termina compartiendo sobre lo que hace por detrás.&#x20;

El argumento es:&#x20;

```
-v (0-6) 
```

Por ejemplo:&#x20;

```
-v 3 
```

Además de la opción de verbose también podemos tunelizar por Burpsuite las peticiones que realice, de esta manera podemos ver todas las peticiones, entenderlas, seleccionar aquellas que queremos que se envíen y las que no, ver las respuestas del servidor…

### ¿Cómo tunelizar por Burpsuite?

Tenemos algunas opciones para hacerlo, en primer lugar tenemos el argumento proxy:&#x20;

```
--proxy=’http://127.0.0.1:8080’ 
```

Simplemente con esto ya estaríamos tunelizando por Burpsuite y podríamos comprobar las distintas peticiones, además si nos vamos a la ayuda de Sqlmap veremos que tenemos la opción de introducir credenciales si es un proxy que lo requiera, cargar una serie de proxy de un archivo…&#x20;

Pero además de esto también existe un addon concreto para Burpsuite que nos permite utilizar Sqlmap desde él. Se llama ‘SQLIPy Sqlmap Integration’ podéis verlo dentro de Burpsuite - Extender - BApp Store. Os dejo una captura de una parte del addon en la Figura 3.

![Figura 3: SQLIPy Sqlmap Integration](https://lh3.googleusercontent.com/gzAcCTkxM6OAoCc-NDdYpqArvTDmZARDWi4GqPlLooswRTuL5nwSJW35MlzEQ-dZMp4NpJawmySZIEx5iHSaXfdv-RiIr1I5h9BlQCYi6Nmep7a2stxonETUpJV\_2lVVMNl4awT56Evx-cWYbg)

Cómo hemos podido ver no hay excusas para no aprender a utilizar Sqlmap cómo unos profesionales, entender qué estamos haciendo y seguir aprendiendo con una pequeña ayuda de la mano.&#x20;

Recordad que siempre podéis acceder al comando help, tenéis multitud de manuales y ejemplos en Internet, y en definitiva muchos de estos programas pueden resultar extremadamente útiles y complejos.

## Ejemplo de uso

Pongamos un caso, en este caso concreto tenemos el siguiente Login Figura 4.

![Figura 4: Formulario de Login](https://lh3.googleusercontent.com/Aa7IE6Tuot8Ae0ftA65u9yPdhDHI47VtVNsLHcByZX3diwVt2EFJQGGC5UbQCmsd94RVi3hbRUfTXn5JMBm9mLhwHFyer32ufU4JcwVDH\_h3aErCaICzYfHx9Clzh8kyAyns6gd9mDbr5onBPw)

Tras hacer algunas pruebas vemos que es vulnerable a un SQLI Time Based ya que tras introducir el siguiente Payload vemos que efectivamente al existir un usuario llamado ‘admin’ en la base de datos tarda 5 segundos en devolver la respuesta:

```
admin’ and sleep(5)-- -
```

![Figura 5: Payload en Username](https://lh3.googleusercontent.com/hxK7d0xXjpj6ut9x\_tbu\_ZBxwGNr8jurD80YOEphJtNwn\_59cfsGp6O5XAizxw3vIkECYsmMauxeu\_MmrYKp8D9d4l002nppK5QFy8Z3AIp2ZLhAWnglF0AilQSJgFJOGFJktb4kDcpJjX9Cvg)

¿Tendría sentido entonces con todo lo que hemos visto lanzar un Sqlmap a lo loco y que lance peticiones a diestro y siniestro? ¿O podríamos hacerlo mucho más efectivo?&#x20;

Sabemos el tipo de inyección que queremos y estamos bastante convencidos de la base de datos que trabaja detrás, así que vamos a generar unos argumentos algo mejores.&#x20;

¿Cómo es la data que se transmite por POST? Figura 6.

![Figura 6: Data](https://lh4.googleusercontent.com/zxrfOc3KHFvVdR-qlbV6IjSAveWBujsT84PM7VMOuhGms53ucSbqvuN-h6paYlLPPIobxSgS76OBgU9f13GdCAZsJrJfPb4zADZ27h9K3qu9P2qdHoyIeI2usVnFdkOuXFyFVr7BL8qPVbi2-w)

```
sqlmap -u "http://10.129.97.150/" --data "username=usuario&password=contrasena" --technique=T --dbms=mysql -p "username" --current-db --proxy='http://127.0.0.1:8080' 
```

* \-u → Introducimos el objetivo.&#x20;
* \--data → La data que se va a transmitir por POST.&#x20;
* \--technique → La técnica que se va a utilizar.&#x20;
* \--dbms → La base de datos que trabaja detrás.&#x20;
* \-p → Parámetro inyectable&#x20;
* \--proxy → Tunelizamos por Burpsuite.&#x20;
* \--current-db → Queremos obtener únicamente el nombre de la base de datos en uso.&#x20;

Nada más comenzar cuando está haciendo las comprobaciones de si efectivamente es vulnerable y no es un falso positivo únicamente ha hecho 2 peticiones que pudiesen resultar extrañas a ojos de un administrador Figura 7.

![Figura 7: Payload de Sqlmap por Burpsuite](https://lh5.googleusercontent.com/7fZiURviUnzXvN5e68KJ\_xOLw0XHyHh\_WNow5CxJZr3gE\_Bg2r9\_CzTPITEzoVpfxllGD-UJM7gsufsiqe7Jcu9QA4TwMGCsFBEbkJp8Y3tle6-sQMW3mSoS6WW\_1loUB5V9MhByMKxEfuC7lA)

Además tiene la parte positiva de que el propio Sqlmap te ayuda en ocasiones preguntándote si quieres optimizar ciertos valores. Tras todo esto vemos que nos ha sacado el nombre de la base de datos Figura 8.

![Figura 8: Output de Sqlmap](https://lh6.googleusercontent.com/1jyQbG9mhyYvEGuxAEnBmc4QYP9OIdoUIz8MLZ\_wI5Ih0stxZ7rswnrscHxajxiYv6PGBmJeyLSElNLb5KMtOq0tIb0mONvalCRvyORSqdcsuND8RfSIAOFgJVs\_MWeGaPral2sibo1XwHfwNA)

Además al haberlo tunelizado por Burpsuite podríamos comprobar de qué manera está realizando las peticiones Figura 9.

![Figura 9: Peticiones por Burpsuite](https://lh4.googleusercontent.com/TY\_oT0UiBQ9sWGOvd\_I-fIT861juKYu9riesBaUyI5leGuhkaIJATX0G-V6pouAeehbKBba-HpBmv3-rm9xsxvSyNkAIcTwoWTwdfs4mcv1zq5Gu2H5kp8Eo9v3R\_5CP5paFwjJbxJ6mgy6cZg)

Es verdad que ha realizado muchísimas peticiones, pero hay que tener en cuenta que estamos realizando un ataque basado en tiempo, por lo que el número de peticiones va a ser bastante elevado, si nos fijamos en el Payload y nos paramos a entenderlo veremos cómo está sacando letra a letra el nombre de la base de datos que hemos pedido.&#x20;

Ahora que sabemos el nombre de la base de datos podríamos pedir por ejemplo las tablas, luego las columnas y por último los datos. En este caso con la demora que llevaría realizarlo imaginad que le decimos que intente dumpear todos y cada uno de los datos, por esa razón es importante ir poco a poco, entendiendo lo que se hace y controlándolo.&#x20;

También podríamos incluso probar a través de fuerza bruta por diccionario para sacar el nombre de las tablas típicas y partir de ahí, eso ya depende de cada uno.

### Complicando el asunto

De hecho imaginad que quisiésemos intentar ser más sigilosos, hacerlo mediante TOR, con cierto delay entre cada petición para no hacer saltar alarmas y además intentar ocultar un poco el Payload a los WAFs:&#x20;

```
sqlmap -u "http://10.129.97.150/" --data "username=usuario&password=contrasena" --technique=T --dbms=mysql -p "username" --current-db --tor --tor-type=SOCKS5 --check-tor --user-agent=”Googlebot(compatible; Googlebot/2.1; +http://www.google.com/bot.html)” --tamper=”space2comment,charencode.py” --delay=5 
```

Muy similar a lo que hemos hecho antes pero con algunos añadidos:&#x20;

* tor → Para poder realizarlo a través de tor e impedir que nuestra IP aparezca, además de poder ir modificando las IPs cada cierto tiempo.&#x20;
* user-agent → Para hacernos pasar por el robot de google.&#x20;
* tamper → Para ofuscar el payload.&#x20;
* delay → Para evitar que salte alguna alarma por exceso de peticiones en poco tiempo.&#x20;

Cómo veis nos podemos complicar todo lo que queramos hasta niveles insospechados, de hecho podríamos incluso querer que el tiempo de espera sea aleatorio ya que algunos WAFs podrían determinar que las peticiones se realizan en un intervalo concreto de tiempo.&#x20;

Por suerte si googleamos un poco hay alguien que se le ha ocurrido como hacerlo y nos da la respuesta:&#x20;

```
--eval="import time; import random; time.sleep(random.randint(1,10))" 
```

{% embed url="https://github.com/sqlmapproject/sqlmap/issues/2256" %}

Las posibilidades que tenemos son infinitas, y este tipo de programas bien usados son una gran herramienta que nos permite encontrar oro donde sin saber utilizarlo nos quedamos con las manos vacías. Espero que os haya sido de utilidad y gracias por haber prestado vuestro tiempo y atención.
